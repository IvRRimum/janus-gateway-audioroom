/*! \file   cm_audioroom.c
 * \author Lorenzo Miniero <lorenzo@meetecho.com>
 * \copyright GNU General Public License v3
 * \brief  Janus AudioBridge plugin
 * \details  This is a plugin implementing an audio conference bridge for
 * Janus, specifically mixing Opus streams. This means that it replies
 * by providing in the SDP only support for Opus, and disabling video.
 * Opus encoding and decoding is implemented using libopus (http://opus.codec.org).
 * The plugin provides an API to allow peers to join and leave conference
 * rooms. Peers can then mute/unmute themselves by sending specific messages
 * to the plugin: any way a peer mutes/unmutes, an event is triggered
 * to the other participants, so that it can be rendered in the UI
 * accordingly.
 *
 * Rooms to make available are listed in the plugin configuration file.
 * A pre-filled configuration file is provided in \c conf/janus.plugin.audioroom.cfg
 * and includes a demo room for testing.
 *
 * To add more rooms or modify the existing one, you can use the following
 * syntax:
 *
 * \verbatim
[<unique room ID>]
description = This is my awesome room
is_private = yes|no (private rooms don't appear when you do a 'list' request)
secret = <optional password needed for manipulating (e.g. destroying) the room>
pin = <optional password needed for joining the room>
sampling_rate = <sampling rate> (e.g., 16000 for wideband mixing)
record = true|false (whether this room should be recorded, default=false)
record_file =	/path/to/recording.wav (where to save the recording)
\endverbatim
 *
 * \section bridgeapi Audio Bridge API
 *
 * The Audio Bridge API supports several requests, some of which are
 * synchronous and some asynchronous. There are some situations, though,
 * (invalid JSON, invalid request) which will always result in a
 * synchronous error response even for asynchronous requests.
 *
 * \c create , \c destroy , \c exists, \c list, \c listparticipants
 * and \c resetdecoder are synchronous requests, which means you'll
 * get a response directly within the context of the transaction.
 * \c create allows you to create a new audio conference bridge
 * dynamically, as an alternative to using the configuration file;
 * \c destroy removes an audio conference bridge and destroys it, kicking
 * all the users out as part of the process; \c exists allows you to
 * check whether a specific audio conference exists; \c list
 * lists all the available rooms, while \c listparticipants lists all
 * the participants of a specific room and their details; finally,
 * \c resetdecoder marks the Opus decoder for the participant as invalid,
 * and forces it to be recreated (which might be needed if the audio
 * for generated by the participant becomes garbled).
 *
 * The \c join , \c configure , \c changeroom and \c leave requests
 * instead are all asynchronous, which means you'll get a notification
 * about their success or failure in an event. \c join allows you to
 * join a specific audio conference bridge; \c configure can be used
 * to modify some of the participation settings (e.g., mute/unmute);
 * \c changeroom can be used to leave the current room and move to a
 * different one without having to tear down the PeerConnection and
 * recreate it again (useful for sidebars and "waiting rooms"); finally,
 * \c leave allows you to leave an audio conference bridge for good.
 *
 * \c create can be used to create a new audio room, and has to be
 * formatted as follows:
 *
\verbatim
{
	"request" : "create",
	"id" : <unique numeric ID, optional, chosen by plugin if missing>,
	"description" : "<pretty name of the room, optional>",
	"secret" : "<password required to edit/destroy the room, optional>",
	"pin" : "<password required to join the room, optional>",
	"is_private" : <true|false, whether the room should appear in a list request>,
	"sampling" : <sampling rate of the room, optional, 16000 by default>,
	"record" : <true|false, whether to record the room or not, default false>,
	"record_file" : "</path/to/the/recording.wav, optional>",
}
\endverbatim
 *
 * A successful creation procedure will result in a \c created response:
 *
\verbatim
{
	"audioroom" : "created",
	"id" : <unique numeric ID>
}
\endverbatim
 *
 * An error instead (and the same applies to all other requests, so this
 * won't be repeated) would provide both an error code and a more verbose
 * description of the cause of the issue:
 *
\verbatim
{
	"audioroom" : "event",
	"error_code" : <numeric ID, check Macros below>,
	"error" : "<error description as a string>"
}
\endverbatim
 *
 * On the other hand, \c destroy can be used to destroy an existing audio
 * room, whether created dynamically or statically, and has to be
 * formatted as follows:
 *
\verbatim
{
	"request" : "destroy",
	"id" : <unique numeric ID of the room to destroy>,
	"secret" : "<room secret, mandatory if configured>"
}
\endverbatim
 *
 * A successful destruction procedure will result in a \c destroyed response:
 *
\verbatim
{
	"audioroom" : "created",
	"id" : <unique numeric ID>
}
\endverbatim
 *
 * You can check whether a room exists using the \c exists request,
 * which has to be formatted as follows:
 *
\verbatim
{
	"request" : "exists",
	"id" : <unique numeric ID of the room to check>
}
\endverbatim
 *
 * A successful request will result in a \c success response:
 *
\verbatim
{
	"audioroom" : "success",
	"id" : <unique numeric ID>,
	"exists" : <true|false>
}
\endverbatim
 *
 * To get a list of the available rooms (excluded those configured or
 * created as private rooms) you can make use of the \c list request,
 * which has to be formatted as follows:
 *
\verbatim
{
	"request" : "list"
}
\endverbatim
 *
 * A successful request will produce a list of rooms in a \c success response:
 *
\verbatim
{
	"audioroom" : "success",
	"rooms" : [		// Array of room objects
		{	// Room #1
			"id" : <unique numeric ID>,
			"description" : "<Name of the room>",
			"sampling_rate" : <sampling rate of the mixer>,
			"record" : <true|false, whether the room is being recorded>,
			"num_participants" : <count of the participants>
		},
		// Other rooms
	]
}
\endverbatim
 *
 * To get a list of the participants in a specific room, instead, you
 * can make use of the \c listparticipants request, which has to be
 * formatted as follows:
 *
\verbatim
{
	"request" : "listparticipants",
	"id" : <unique numeric ID of the room>
}
\endverbatim
 *
 * A successful request will produce a list of participants in a
 * \c participants response:
 *
\verbatim
{
	"audioroom" : "participants",
	"id" : <unique numeric ID of the room>,
	"participants" : [		// Array of participant objects
		{	// Participant #1
			"userid" : <unique numeric ID of the participant>,
			"display" : "<display name of the participant, if any; optional>",
			"muted" : <true|false, whether user is muted or not>
		},
		// Other participants
	]
}
\endverbatim
 *
 * To mark the Opus decoder context for the current participant as
 * invalid and force it to be recreated, use the \c resetdecoder request:
 *
\verbatim
{
	"request" : "resetdecoder"
}
\endverbatim
 *
 * A successful request will produce a \c success response:
 *
\verbatim
{
	"audioroom" : "success"
}
\endverbatim
 *
 * That completes the list of synchronous requests you can send to the
 * AudioBridge plugin. As anticipated, though, there are also several
 * asynchronous requests you can send, specifically those related to
 * joining and updating one's presence as a participant in an audio room.
 *
 * The way you'd interact with the plugin is usually as follows:
 *
 * -# you use a \c join request to join an audio room, and wait for the
 * \c joined event; this event will also include a list of the other
 * participants, if any;
 * -# you send a \c configure request attached to an audio-only JSEP offer
 * to start configuring your participation in the room (e.g., join unmuted
 * or muted), and wait for a \c configured event, which will be attached
 * to a JSEP answer by the plugin to complete the setup of the WebRTC
 * PeerConnection;
 * -# you send other \c configure requests (without any JSEP-related
 * attachment) to mute/unmute yourself during the audio conference;
 * -# you intercept events originated by the plugin (\c joined , \c leaving )
 * to notify you about users joining/leaving/muting/unmuting;
 * -# you eventually send a \c leave request to leave a room; if you leave the
 * PeerConnection instance intact, you can subsequently join a different
 * room without requiring a new negotiation (and so just use a \c join + JSEP-less \c configure to join).
 *
 * Notice that there's also a \c changeroom request available: you can use
 * this request to immediately leave the room you're in and join a different
 * one, without requiring you to do a \c leave + \c join + \c configure
 * round. Of course remember not to pass any JSEP-related payload when
 * doing a \c changeroom as the same pre-existing PeerConnection will be
 * re-used for the purpose.
 *
 * About the syntax of all the above mentioned requests, \c join has
 * to be formatted as follows:
 *
\verbatim
{
	"request" : "join",
	"id" : <numeric ID of the room to join>,
	"userid" : <unique ID to assign to the participant; optional, assigned by the plugin if missing>,
	"pin" : "<password required to join the room, if any; optional>",
	"display" : "<display name to have in the room; optional>",
	"muted" : <true|false, whether to start unmuted or muted>,
	"quality" : <0-10, Opus-related complexity to use, lower is higher quality; optional, default is 4>
}
\endverbatim
 *
 * A successful request will produce a \c joined event:
 *
\verbatim
{
	"audioroom" : "joined",
	"id" : <numeric ID of the room>,
	"userid" : <unique ID assigned to the participant>,
	"display" : "<display name of the new participant>",
	"participants" : [
		// Array of existing participants in the room
	]
}
\endverbatim
 *
 * The other participants in the room will be notified about the new
 * participant by means of a different \c joined event, which will only
 * include the \c room and the new participant as the only object in
 * a \c participants array.
 *
 * At this point, the media-related settings of the participant can be
 * modified by means of a \c configure request. The \c configure request
 * has to be formatted as follows:
 *
\verbatim
{
	"request" : "configure",
	"muted" : <true|false, whether to unmute or mute>,
	"quality" : <0-10, Opus-related complexity to use, lower is higher quality; optional, default is 4>,
}
\endverbatim
 *
 * \c muted instructs the plugin to mute or unmute the participant;
 * \c quality changes the complexity of the Opus encoder for the
 * participant. A successful request will result in a \c ok event:
 *
\verbatim
{
	"audioroom" : "event",
	"id" : <numeric ID of the room>,
	"result" : "ok"
}
\endverbatim
 *
 * In case the \c muted property was modified, the other participants in
 * the room will be notified about this by means of a \c event notification,
 * which will only include the \c room and the updated participant as the
 * only object in a \c participants array.
 *
 * As anticipated, you can leave an audio room using the \c leave request,
 * which has to be formatted as follows:
 *
\verbatim
{
	"request" : "leave"
}
\endverbatim
 *
 * All the participants will receive an \c event notification with the
 * ID of the participant who just left:
 *
\verbatim
{
	"audioroom" : "event",
	"id" : <numeric ID of the room>,
	"leaving" : <numeric ID of the participant who left>
}
\endverbatim
 *
 * For what concerns the \c changeroom request, instead, it's pretty much
 * the same as a \c join request and as such has to be formatted as follows:
 *
\verbatim
{
	"request" : "changeroom",
	"id" : <numeric ID of the room to move to>,
	"userid" : <unique ID to assign to the participant; optional, assigned by the plugin if missing>,
	"display" : "<display name to have in the room; optional>",
	"muted" : <true|false, whether to start unmuted or muted>,
	"quality" : <0-10, Opus-related complexity to use, lower is higher quality; optional, default is 4>
}
\endverbatim
 *
 * Such a request will trigger all the above-described leaving/joined
 * events to the other participants, as it is indeed wrapping a \c leave
 * followed by a \c join and as such the other participants in both rooms
 * need to be updated accordingly. The participant who switched room
 * instead will be sent a \c roomchanged event which is pretty similar
 * to what \c joined looks like:
 *
 * A successful request will produce a \c joined event:
 *
\verbatim
{
	"audioroom" : "roomchanged",
	"id" : <numeric ID of the new room>,
	"userid" : <unique ID assigned to the participant in the new room>,
	"display" : "<display name of the new participant>",
	"participants" : [
		// Array of existing participants in the new room
	]
}
\endverbatim
 *
 * \ingroup plugins
 * \ref plugins
 */

#include "plugins/plugin.h"

#include <jansson.h>
#include <opus/opus.h>
#include <sys/time.h>

#include "debug.h"
#include "apierror.h"
#include "config.h"
#include "mutex.h"
#include "rtp.h"
#include "rtcp.h"
#include "utils.h"


/* Plugin information */
#define CM_AUDIOROOM_VERSION			8
#define CM_AUDIOROOM_VERSION_STRING	"0.0.8"
#define CM_AUDIOROOM_DESCRIPTION		"This is a plugin implementing an audio conference bridge for Janus, mixing Opus streams."
#define CM_AUDIOROOM_NAME				"JANUS CM audio plugin"
#define CM_AUDIOROOM_AUTHOR			"Meetecho s.r.l."
#define CM_AUDIOROOM_PACKAGE			"janus.plugin.audioroom"

/* Plugin methods */
janus_plugin *create(void);
int cm_audioroom_init(janus_callbacks *callback, const char *config_path);
void cm_audioroom_destroy(void);
int cm_audioroom_get_api_compatibility(void);
int cm_audioroom_get_version(void);
const char *cm_audioroom_get_version_string(void);
const char *cm_audioroom_get_description(void);
const char *cm_audioroom_get_name(void);
const char *cm_audioroom_get_author(void);
const char *cm_audioroom_get_package(void);
void cm_audioroom_create_session(janus_plugin_session *handle, int *error);
struct janus_plugin_result *cm_audioroom_handle_message(janus_plugin_session *handle, char *transaction, char *message, char *sdp_type, char *sdp);
void cm_audioroom_setup_media(janus_plugin_session *handle);
void cm_audioroom_incoming_rtp(janus_plugin_session *handle, int video, char *buf, int len);
void cm_audioroom_incoming_rtcp(janus_plugin_session *handle, int video, char *buf, int len);
void cm_audioroom_hangup_media(janus_plugin_session *handle);
void cm_audioroom_destroy_session(janus_plugin_session *handle, int *error);
char *cm_audioroom_query_session(janus_plugin_session *handle);

static struct {
	const char *archive_path;
	const char *recording_pattern;
} cm_audioroom_settings;


/* Plugin setup */
static janus_plugin cm_audioroom_plugin =
	JANUS_PLUGIN_INIT (
		.init = cm_audioroom_init,
		.destroy = cm_audioroom_destroy,

		.get_api_compatibility = cm_audioroom_get_api_compatibility,
		.get_version = cm_audioroom_get_version,
		.get_version_string = cm_audioroom_get_version_string,
		.get_description = cm_audioroom_get_description,
		.get_name = cm_audioroom_get_name,
		.get_author = cm_audioroom_get_author,
		.get_package = cm_audioroom_get_package,

		.create_session = cm_audioroom_create_session,
		.handle_message = cm_audioroom_handle_message,
		.setup_media = cm_audioroom_setup_media,
		.incoming_rtp = cm_audioroom_incoming_rtp,
		.incoming_rtcp = cm_audioroom_incoming_rtcp,
		.hangup_media = cm_audioroom_hangup_media,
		.destroy_session = cm_audioroom_destroy_session,
		.query_session = cm_audioroom_query_session,
	);

/* Plugin creator */
janus_plugin *create(void) {
	JANUS_LOG(LOG_VERB, "%s created!\n", CM_AUDIOROOM_NAME);
	return &cm_audioroom_plugin;
}


/* Useful stuff */
static volatile gint initialized = 0, stopping = 0;
static janus_callbacks *gateway = NULL;
static GThread *handler_thread;
static GThread *watchdog;
static void *cm_audioroom_handler(void *data);
static void cm_audioroom_relay_rtp_packet(gpointer data, gpointer user_data);
static void *cm_audioroom_mixer_thread(void *data);
static void *cm_audioroom_participant_thread(void *data);

/* Helper to remove insane code duplication everywhere
 	 Sample illustrating use:
			something things[] = { X, Y, Z };
			_foreach(i, things) {
				print(things[i]);
			}

			Note, iterator variable exported in the current scope;
			*/
#define _foreach(var, container) size_t var; for (var = 0; var < sizeof(container)/sizeof(container[0]); var++)

typedef struct cm_audioroom_message {
	janus_plugin_session *handle;
	char *transaction;
	json_t *message;
	char *sdp_type;
	char *sdp;
} cm_audioroom_message;
static GAsyncQueue *messages = NULL;

void cm_audioroom_message_free(cm_audioroom_message *msg);
void cm_audioroom_message_free(cm_audioroom_message *msg) {
	if(!msg)
		return;

	msg->handle = NULL;

	g_free(msg->transaction);
	msg->transaction = NULL;
	if(msg->message)
		json_decref(msg->message);
	msg->message = NULL;
	g_free(msg->sdp_type);
	msg->sdp_type = NULL;
	g_free(msg->sdp);
	msg->sdp = NULL;

	g_free(msg);
}


typedef struct cm_audioroom_room {
	gchar *room_id;			/* Unique room ID */
	gchar *room_name;			/* Room description */
	gchar *room_secret;			/* Secret needed to manipulate (e.g., destroy) this room */
	gchar *room_pin;			/* Password needed to join this room, if any */
	gboolean is_private;			/* Whether this room is 'private' (as in hidden) or not */
	uint32_t sampling_rate;		/* Sampling rate of the mix (e.g., 16000 for wideband; can be 8, 12, 16, 24 or 48kHz) */
	gboolean record;			/* Whether this room has to be recorded or not */
	gchar *record_file;			/* Path of the recording file */
	FILE *recording;			/* File to record the room into */
	gboolean destroy;			/* Value to flag the room for destruction */
	GHashTable *participants;	/* Map of participants */
	GThread *thread;			/* Mixer thread for this room */
	gint64 destroyed;			/* When this room has been destroyed */
	janus_mutex mutex;			/* Mutex to lock this room instance */
} cm_audioroom_room;
static GHashTable *rooms;
static janus_mutex rooms_mutex;

typedef struct cm_audioroom_session {
	janus_plugin_session *handle;
	gpointer participant;
	gboolean started;
	gboolean stopping;
	volatile gint hangingup;
	gint64 destroyed;	/* Time at which this session was marked as destroyed */
} cm_audioroom_session;
static GHashTable *sessions;
static GList *old_sessions;
static janus_mutex sessions_mutex;

typedef struct cm_audioroom_rtp_context {
	/* Needed to fix seq and ts in case of publisher switching */
	uint32_t a_last_ssrc, a_last_ts, a_base_ts, a_base_ts_prev;
	uint16_t a_last_seq, a_base_seq, a_base_seq_prev;
} cm_audioroom_rtp_context;

typedef struct cm_audioroom_participant {
	cm_audioroom_session *session;
	cm_audioroom_room *room;	/* Room */
	guint64 user_id;		/* Unique ID in the room */
	gchar *display;			/* Display name (just for fun) */
	gboolean prebuffering;	/* Whether this participant needs pre-buffering of a few packets (just joined) */
	gboolean active;		/* Whether this participant can receive media at all */
	gboolean working;		/* Whether this participant is currently encoding/decoding */
	gboolean muted;			/* Whether this participant is muted */
	int opus_complexity;	/* Complexity to use in the encoder (by default, DEFAULT_COMPLEXITY) */
	/* RTP stuff */
	GList *inbuf;			/* Incoming audio from this participant, as an ordered list of packets */
	GAsyncQueue *outbuf;	/* Mixed audio for this participant */
	janus_mutex qmutex;		/* Incoming queue mutex */
	int opus_pt;			/* Opus payload type */
	cm_audioroom_rtp_context context;	/* Needed in case the participant changes room */
	/* Opus stuff */
	OpusEncoder *encoder;		/* Opus encoder instance */
	OpusDecoder *decoder;		/* Opus decoder instance */
	gboolean reset;				/* Whether or not the Opus context must be reset, without re-joining the room */
	GThread *thread;			/* Encoding thread for this participant */
	gint64 destroyed;			/* When this participant has been destroyed */
} cm_audioroom_participant;

/* Packets we get from gstreamer and relay */
typedef struct cm_audioroom_rtp_relay_packet {
	rtp_header *data;
	gint length;
	uint32_t ssrc;
	uint32_t timestamp;
	uint16_t seq_number;
} cm_audioroom_rtp_relay_packet;

/* Helper to sort incoming RTP packets by sequence numbers */
static gint cm_audioroom_rtp_sort(gconstpointer a, gconstpointer b) {
	cm_audioroom_rtp_relay_packet *pkt1 = (cm_audioroom_rtp_relay_packet *)a;
	cm_audioroom_rtp_relay_packet *pkt2 = (cm_audioroom_rtp_relay_packet *)b;
	if(pkt1->seq_number < 100 && pkt2->seq_number > 65000) {
		/* Sequence number was probably reset, pkt2 is older */
		return 1;
	} else if(pkt2->seq_number < 100 && pkt1->seq_number > 65000) {
		/* Sequence number was probably reset, pkt1 is older */
		return -1;
	}
	/* Simply compare timestamps */
	if(pkt1->seq_number < pkt2->seq_number)
		return -1;
	else if(pkt1->seq_number > pkt2->seq_number)
		return 1;
	return 0;
}

/* SDP offer/answer template */
#define sdp_template \
		"v=0\r\n" \
		"o=- %"SCNu64" %"SCNu64" IN IP4 127.0.0.1\r\n"	/* We need current time here */ \
		"s=%s\r\n"							/* Audio bridge name */ \
		"t=0 0\r\n" \
		"m=audio 1 RTP/SAVPF %d\r\n"		/* Opus payload type */ \
		"c=IN IP4 1.1.1.1\r\n" \
		"a=rtpmap:%d opus/48000/2\r\n"		/* Opus payload type */ \
		"a=fmtp:%d maxplaybackrate=%"SCNu32"; stereo=0; sprop-stereo=0; useinbandfec=0\r\n" \
											/* Opus payload type and room sampling rate */

/* Helper struct to generate and parse WAVE headers */
typedef struct wav_header {
	char riff[4];
	uint32_t len;
	char wave[4];
	char fmt[4];
	uint32_t formatsize;
	uint16_t format;
	uint16_t channels;
	uint32_t samplerate;
	uint32_t avgbyterate;
	uint16_t samplebytes;
	uint16_t channelbits;
	char data[4];
	uint32_t blocksize;
} wav_header;


/* Mixer settings */
#define DEFAULT_PREBUFFERING	6


/* Opus settings */
#define	BUFFER_SAMPLES	8000
#define	OPUS_SAMPLES	160
#define USE_FEC			0
#define DEFAULT_COMPLEXITY	4


/* Error codes */
#define CM_AUDIOROOM_ERROR_UNKNOWN_ERROR	499
#define CM_AUDIOROOM_ERROR_NO_MESSAGE		480
#define CM_AUDIOROOM_ERROR_INVALID_JSON	481
#define CM_AUDIOROOM_ERROR_INVALID_REQUEST	482
#define CM_AUDIOROOM_ERROR_MISSING_ELEMENT	483
#define CM_AUDIOROOM_ERROR_INVALID_ELEMENT	484
#define CM_AUDIOROOM_ERROR_NO_SUCH_ROOM	485
#define CM_AUDIOROOM_ERROR_ROOM_EXISTS		486
#define CM_AUDIOROOM_ERROR_NOT_JOINED		487
#define CM_AUDIOROOM_ERROR_LIBOPUS_ERROR	488
#define CM_AUDIOROOM_ERROR_UNAUTHORIZED	489
#define CM_AUDIOROOM_ERROR_ID_EXISTS		490
#define CM_AUDIOROOM_ERROR_ALREADY_JOINED	491


/* AudioBridge watchdog/garbage collector (sort of) */
void *cm_audioroom_watchdog(void *data);
void *cm_audioroom_watchdog(void *data) {
	JANUS_LOG(LOG_INFO, "AudioBridge watchdog started\n");
	gint64 now = 0;
	while(g_atomic_int_get(&initialized) && !g_atomic_int_get(&stopping)) {
		janus_mutex_lock(&sessions_mutex);
		/* Iterate on all the sessions */
		now = janus_get_monotonic_time();
		if(old_sessions != NULL) {
			GList *sl = old_sessions;
			JANUS_LOG(LOG_HUGE, "Checking %d old AudioBridge sessions...\n", g_list_length(old_sessions));
			while(sl) {
				cm_audioroom_session *session = (cm_audioroom_session *)sl->data;
				if(!session) {
					sl = sl->next;
					continue;
				}
				if(now-session->destroyed >= 5*G_USEC_PER_SEC) {
					/* We're lazy and actually get rid of the stuff only after a few seconds */
					JANUS_LOG(LOG_VERB, "Freeing old AudioBridge session\n");
					GList *rm = sl->next;
					old_sessions = g_list_delete_link(old_sessions, sl);
					sl = rm;
					session->handle = NULL;
					g_free(session);
					session = NULL;
					continue;
				}
				sl = sl->next;
			}
		}
		janus_mutex_unlock(&sessions_mutex);
		g_usleep(500000);
	}
	JANUS_LOG(LOG_INFO, "AudioBridge watchdog stopped\n");
	return NULL;
}


/* Plugin implementation */
int cm_audioroom_init(janus_callbacks *callback, const char *config_path) {
	if(g_atomic_int_get(&stopping)) {
		/* Still stopping from before */
		return -1;
	}
	if(callback == NULL || config_path == NULL) {
		/* Invalid arguments */
		return -1;
	}

	/* Read configuration */
	char filename[255];
	g_snprintf(filename, 255, "%s/%s.cfg", config_path, CM_AUDIOROOM_PACKAGE);
	JANUS_LOG(LOG_VERB, "Configuration file: %s\n", filename);
	janus_config *config = janus_config_parse(filename);
	if(config != NULL)
		janus_config_print(config);

	rooms = g_hash_table_new_full(
		g_str_hash,	 /* Hashing func */
		g_str_equal, /* Key comparator */
		g_free,			 /* Key destructor */
		NULL);			 /* Value destructor, we don't want this done automatically */
	janus_mutex_init(&rooms_mutex);
	sessions = g_hash_table_new(NULL, NULL);
	janus_mutex_init(&sessions_mutex);
	messages = g_async_queue_new_full((GDestroyNotify) cm_audioroom_message_free);
	/* This is the callback we'll need to invoke to contact the gateway */
	gateway = callback;

	cm_audioroom_settings.archive_path =  g_strdup("/tmp/recordings");
	cm_audioroom_settings.recording_pattern = g_strdup("rec-%1$s-%2$llu-audioroom");

	/* Parse configuration to populate the rooms list */
	if(config != NULL) {
		const char *inames [] = {
		 "archive_path",
		 "recording_pattern",
		};
		const char **ivars [] = {
			&cm_audioroom_settings.archive_path,
			&cm_audioroom_settings.recording_pattern,
		};

		_foreach(i, ivars) {
			janus_config_item *itm = janus_config_get_item_drilldown(config, "general", inames[i]);
			if (itm && itm->value) {
				g_free((gpointer)*ivars[i]);
				*ivars[i] = g_strdup(itm->value);
			}
		}
		/* FIXME @landswellsong free the g_strdup in de-init() */
		/* Done */
		janus_config_destroy(config);
		config = NULL;
	}

	/* Show available rooms */
	janus_mutex_lock(&rooms_mutex);
	GHashTableIter iter;
	gpointer value;
	g_hash_table_iter_init(&iter, rooms);
	while (g_hash_table_iter_next(&iter, NULL, &value)) {
		cm_audioroom_room *ar = value;
		JANUS_LOG(LOG_VERB, "  ::: [%s][%s] %"SCNu32" (%s be recorded)\n",
			ar->room_id, ar->room_name, ar->sampling_rate, ar->record ? "will" : "will NOT");
	}
	janus_mutex_unlock(&rooms_mutex);

	g_atomic_int_set(&initialized, 1);

	GError *error = NULL;
	/* Start the sessions watchdog */
	watchdog = g_thread_try_new("abridge watchdog", &cm_audioroom_watchdog, NULL, &error);
	if(error != NULL) {
		g_atomic_int_set(&initialized, 0);
		JANUS_LOG(LOG_ERR, "Got error %d (%s) trying to launch the AudioBridge watchdog thread...\n", error->code, error->message ? error->message : "??");
		return -1;
	}
	/* Launch the thread that will handle incoming messages */
	handler_thread = g_thread_try_new("janus audioroom handler", cm_audioroom_handler, NULL, &error);
	if(error != NULL) {
		g_atomic_int_set(&initialized, 0);
		JANUS_LOG(LOG_ERR, "Got error %d (%s) trying to launch the AudioBridge handler thread...\n", error->code, error->message ? error->message : "??");
		return -1;
	}
	JANUS_LOG(LOG_INFO, "%s initialized!\n", CM_AUDIOROOM_NAME);
	return 0;
}

void cm_audioroom_destroy(void) {
	if(!g_atomic_int_get(&initialized))
		return;
	g_atomic_int_set(&stopping, 1);
	if(handler_thread != NULL) {
		g_thread_join(handler_thread);
		handler_thread = NULL;
	}
	if(watchdog != NULL) {
		g_thread_join(watchdog);
		watchdog = NULL;
	}
	/* FIXME We should destroy the sessions cleanly */
	janus_mutex_lock(&sessions_mutex);
	g_hash_table_destroy(sessions);
	janus_mutex_unlock(&sessions_mutex);
	janus_mutex_lock(&rooms_mutex);
	g_hash_table_destroy(rooms);
	janus_mutex_unlock(&rooms_mutex);
	g_async_queue_unref(messages);
	messages = NULL;
	sessions = NULL;
	g_atomic_int_set(&initialized, 0);
	g_atomic_int_set(&stopping, 0);
	JANUS_LOG(LOG_INFO, "%s destroyed!\n", CM_AUDIOROOM_NAME);
}

int cm_audioroom_get_api_compatibility(void) {
	/* Important! This is what your plugin MUST always return: don't lie here or bad things will happen */
	return JANUS_PLUGIN_API_VERSION;
}

int cm_audioroom_get_version(void) {
	return CM_AUDIOROOM_VERSION;
}

const char *cm_audioroom_get_version_string(void) {
	return CM_AUDIOROOM_VERSION_STRING;
}

const char *cm_audioroom_get_description(void) {
	return CM_AUDIOROOM_DESCRIPTION;
}

const char *cm_audioroom_get_name(void) {
	return CM_AUDIOROOM_NAME;
}

const char *cm_audioroom_get_author(void) {
	return CM_AUDIOROOM_AUTHOR;
}

const char *cm_audioroom_get_package(void) {
	return CM_AUDIOROOM_PACKAGE;
}

void cm_audioroom_create_session(janus_plugin_session *handle, int *error) {
	if(g_atomic_int_get(&stopping) || !g_atomic_int_get(&initialized)) {
		*error = -1;
		return;
	}
	cm_audioroom_session *session = (cm_audioroom_session *)g_malloc0(sizeof(cm_audioroom_session));
	if(session == NULL) {
		JANUS_LOG(LOG_FATAL, "Memory error!\n");
		*error = -2;
		return;
	}
	session->handle = handle;
	session->started = FALSE;
	session->stopping = FALSE;
	session->destroyed = 0;
	g_atomic_int_set(&session->hangingup, 0);
	handle->plugin_handle = session;
	janus_mutex_lock(&sessions_mutex);
	g_hash_table_insert(sessions, handle, session);
	janus_mutex_unlock(&sessions_mutex);

	return;
}

void cm_audioroom_destroy_session(janus_plugin_session *handle, int *error) {
	if(g_atomic_int_get(&stopping) || !g_atomic_int_get(&initialized)) {
		*error = -1;
		return;
	}
	cm_audioroom_session *session = (cm_audioroom_session *)handle->plugin_handle;
	if(!session) {
		JANUS_LOG(LOG_ERR, "No AudioBridge session associated with this handle...\n");
		*error = -2;
		return;
	}
	JANUS_LOG(LOG_VERB, "Removing AudioBridge session...\n");
	janus_mutex_lock(&sessions_mutex);
	if(!session->destroyed) {
		g_hash_table_remove(sessions, handle);
		cm_audioroom_hangup_media(handle);
		session->destroyed = janus_get_monotonic_time();
		/* Cleaning up and removing the session is done in a lazy way */
		old_sessions = g_list_append(old_sessions, session);
	}
	janus_mutex_unlock(&sessions_mutex);

	return;
}

char *cm_audioroom_query_session(janus_plugin_session *handle) {
	if(g_atomic_int_get(&stopping) || !g_atomic_int_get(&initialized)) {
		return NULL;
	}
	cm_audioroom_session *session = (cm_audioroom_session *)handle->plugin_handle;
	if(!session) {
		JANUS_LOG(LOG_ERR, "No session associated with this handle...\n");
		return NULL;
	}
	/* Show the participant/room info, if any */
	json_t *info = json_object();
	cm_audioroom_participant *participant = (cm_audioroom_participant *)session->participant;
	json_object_set_new(info, "state", json_string(participant && participant->room ? "inroom" : "idle"));
	if(participant) {
		cm_audioroom_room *room = participant->room;
		json_object_set_new(info, "id", room ? json_string(room->room_id) : NULL);
		json_object_set_new(info, "userid", json_integer(participant->user_id));
		if(participant->display)
			json_object_set_new(info, "display", json_string(participant->display));
		json_object_set_new(info, "muted", json_string(participant->muted ? "true" : "false"));
		json_object_set_new(info, "active", json_string(participant->active ? "true" : "false"));
		json_object_set_new(info, "pre-buffering", json_string(participant->prebuffering ? "true" : "false"));
		if(participant->inbuf) {
			janus_mutex_lock(&participant->qmutex);
			json_object_set_new(info, "queue-in", json_integer(g_list_length(participant->inbuf)));
			janus_mutex_unlock(&participant->qmutex);
		}
		if(participant->outbuf)
			json_object_set_new(info, "queue-out", json_integer(g_async_queue_length(participant->outbuf)));
	}
	json_object_set_new(info, "started", json_string(session->started ? "true" : "false"));
	json_object_set_new(info, "destroyed", json_integer(session->destroyed));
	char *info_text = json_dumps(info, JSON_INDENT(3) | JSON_PRESERVE_ORDER);
	json_decref(info);
	return info_text;
}

struct janus_plugin_result *cm_audioroom_handle_message(janus_plugin_session *handle, char *transaction, char *message, char *sdp_type, char *sdp) {
	if(g_atomic_int_get(&stopping) || !g_atomic_int_get(&initialized))
		return janus_plugin_result_new(JANUS_PLUGIN_ERROR, g_atomic_int_get(&stopping) ? "Shutting down" : "Plugin not initialized");

	/* Pre-parse the message */
	int error_code = 0;
	char error_cause[512];
	json_t *root = NULL;
	json_t *response = NULL;

	if(message == NULL) {
		JANUS_LOG(LOG_ERR, "No message??\n");
		error_code = CM_AUDIOROOM_ERROR_NO_MESSAGE;
		g_snprintf(error_cause, 512, "%s", "No message??");
		goto error;
	}
	JANUS_LOG(LOG_VERB, "Handling message: %s\n", message);

	cm_audioroom_session *session = (cm_audioroom_session *)handle->plugin_handle;
	if(!session) {
		JANUS_LOG(LOG_ERR, "No session associated with this handle...\n");
		error_code = CM_AUDIOROOM_ERROR_UNKNOWN_ERROR;
		g_snprintf(error_cause, 512, "%s", "session associated with this handle...");
		goto error;
	}
	if(session->destroyed) {
		JANUS_LOG(LOG_ERR, "Session has already been marked as destroyed...\n");
		error_code = CM_AUDIOROOM_ERROR_UNKNOWN_ERROR;
		g_snprintf(error_cause, 512, "%s", "Session has already been marked as destroyed...");
		goto error;
	}
	json_error_t error;
	root = json_loads(message, 0, &error);
	if(!root) {
		JANUS_LOG(LOG_ERR, "JSON error: on line %d: %s\n", error.line, error.text);
		error_code = CM_AUDIOROOM_ERROR_INVALID_JSON;
		g_snprintf(error_cause, 512, "JSON error: on line %d: %s", error.line, error.text);
		goto error;
	}
	if(!json_is_object(root)) {
		JANUS_LOG(LOG_ERR, "JSON error: not an object\n");
		error_code = CM_AUDIOROOM_ERROR_INVALID_JSON;
		g_snprintf(error_cause, 512, "JSON error: not an object");
		goto error;
	}
	/* Get the request first */
	json_t *request = json_object_get(root, "request");
	if(!request) {
		JANUS_LOG(LOG_ERR, "Missing element (request)\n");
		error_code = CM_AUDIOROOM_ERROR_MISSING_ELEMENT;
		g_snprintf(error_cause, 512, "Missing element (request)");
		goto error;
	}
	if(!json_is_string(request)) {
		JANUS_LOG(LOG_ERR, "Invalid element (request should be a string)\n");
		error_code = CM_AUDIOROOM_ERROR_INVALID_ELEMENT;
		g_snprintf(error_cause, 512, "Invalid element (request should be a string)");
		goto error;
	}
	/* Some requests ('create', 'destroy', 'exists', 'list') can be handled synchronously */
	const char *request_text = json_string_value(request);
	if(!strcasecmp(request_text, "create")) {
		/* Create a new audioroom */
		JANUS_LOG(LOG_VERB, "Creating a new audioroom\n");
		json_t *desc = json_object_get(root, "description");
		if(desc && !json_is_string(desc)) {
			JANUS_LOG(LOG_ERR, "Invalid element (description should be a string)\n");
			error_code = CM_AUDIOROOM_ERROR_INVALID_ELEMENT;
			g_snprintf(error_cause, 512, "Invalid element (description should be a string)");
			goto error;
		}
		json_t *secret = json_object_get(root, "secret");
		if(secret && !json_is_string(secret)) {
			JANUS_LOG(LOG_ERR, "Invalid element (secret should be a string)\n");
			error_code = CM_AUDIOROOM_ERROR_INVALID_ELEMENT;
			g_snprintf(error_cause, 512, "Invalid element (secret should be a string)");
			goto error;
		}
		json_t *pin = json_object_get(root, "pin");
		if(pin && !json_is_string(pin)) {
			JANUS_LOG(LOG_ERR, "Invalid element (pin should be a string)\n");
			error_code = CM_AUDIOROOM_ERROR_INVALID_ELEMENT;
			g_snprintf(error_cause, 512, "Invalid element (pin should be a string)");
			goto error;
		}
		json_t *is_private = json_object_get(root, "is_private");
		if(is_private && !json_is_boolean(is_private)) {
			JANUS_LOG(LOG_ERR, "Invalid element (is_private should be a boolean)\n");
			error_code = CM_AUDIOROOM_ERROR_INVALID_ELEMENT;
			g_snprintf(error_cause, 512, "Invalid value (is_private should be a boolean)");
			goto error;
		}
		json_t *sampling = json_object_get(root, "sampling");
		if(sampling && (!json_is_integer(sampling) || json_integer_value(sampling) < 0)) {
			JANUS_LOG(LOG_ERR, "Invalid element (sampling should be a positive integer)\n");
			error_code = CM_AUDIOROOM_ERROR_INVALID_ELEMENT;
			g_snprintf(error_cause, 512, "Invalid element (sampling should be a positive integer)");
			goto error;
		}
		json_t *record = json_object_get(root, "record");
		if(record && !json_is_boolean(record)) {
			JANUS_LOG(LOG_ERR, "Invalid element (record should be a boolean)\n");
			error_code = CM_AUDIOROOM_ERROR_INVALID_ELEMENT;
			g_snprintf(error_cause, 512, "Invalid value (record should be a boolean)");
			goto error;
		}
		json_t *recfile = json_object_get(root, "record_file");
		if(recfile && !json_is_string(recfile)) {
			JANUS_LOG(LOG_ERR, "Invalid element (record_file should be a string)\n");
			error_code = CM_AUDIOROOM_ERROR_INVALID_ELEMENT;
			g_snprintf(error_cause, 512, "Invalid value (record_file should be a string)");
			goto error;
		}
		json_t *room = json_object_get(root, "id");
		if(!room) {
			JANUS_LOG(LOG_ERR, "Missing element (room)\n");
			error_code = CM_AUDIOROOM_ERROR_MISSING_ELEMENT;
			g_snprintf(error_cause, 512, "Missing element (room)");
			goto error;
		}
		if(!json_is_string(room)) {
			JANUS_LOG(LOG_ERR, "Invalid element (room should be a string)\n");
			error_code = CM_AUDIOROOM_ERROR_INVALID_ELEMENT;
			g_snprintf(error_cause, 512, "Invalid element (room should be a string)");
			goto error;
		}
		const gchar *room_id = json_string_value(room);
		janus_mutex_lock(&rooms_mutex);
		/* Let's make sure the room doesn't exist already */
		if(g_hash_table_lookup(rooms, room_id) != NULL) {
			/* It does... */
			janus_mutex_unlock(&rooms_mutex);
			JANUS_LOG(LOG_ERR, "Room %s already exists!\n", room_id);
			error_code = CM_AUDIOROOM_ERROR_ROOM_EXISTS;
			g_snprintf(error_cause, 512, "Room %s already exists", room_id);
			goto error;
		}

		/* Create the audio bridge room */
		cm_audioroom_room *audioroom = g_malloc0(sizeof(cm_audioroom_room));
		if(audioroom == NULL) {
			janus_mutex_unlock(&rooms_mutex);
			JANUS_LOG(LOG_FATAL, "Memory error!\n");
			error_code = CM_AUDIOROOM_ERROR_UNKNOWN_ERROR;
			g_snprintf(error_cause, 512, "Memory error");
			goto error;
		}
		audioroom->room_id = g_strdup(room_id);
		char *description = NULL;
		if(desc != NULL && strlen(json_string_value(desc)) > 0) {
			description = g_strdup(json_string_value(desc));
		} else {
			char roomname[255];
			g_snprintf(roomname, 255, "Room %s", audioroom->room_id);
			description = g_strdup(roomname);
		}
		if(description == NULL) {
			janus_mutex_unlock(&rooms_mutex);
			JANUS_LOG(LOG_FATAL, "Memory error!\n");
			error_code = CM_AUDIOROOM_ERROR_UNKNOWN_ERROR;
			g_snprintf(error_cause, 512, "Memory error");
			goto error;
		}
		audioroom->room_name = description;
		audioroom->is_private = is_private ? json_is_true(is_private) : FALSE;
		if(secret)
			audioroom->room_secret = g_strdup(json_string_value(secret));
		if(pin)
			audioroom->room_pin = g_strdup(json_string_value(pin));
		if(sampling)
			audioroom->sampling_rate = json_integer_value(sampling);
		else
			audioroom->sampling_rate = 16000;
		switch(audioroom->sampling_rate) {
			case 8000:
			case 12000:
			case 16000:
			case 24000:
			case 48000:
				JANUS_LOG(LOG_VERB, "Sampling rate for mixing: %"SCNu32"\n", audioroom->sampling_rate);
				break;
			default:
				janus_mutex_unlock(&rooms_mutex);
				JANUS_LOG(LOG_ERR, "Unsupported sampling rate %"SCNu32"...\n", audioroom->sampling_rate);
				error_code = CM_AUDIOROOM_ERROR_UNKNOWN_ERROR;
				g_snprintf(error_cause, 512, "We currently only support 16kHz (wideband) as a sampling rate for audio rooms, %"SCNu32" TBD...", audioroom->sampling_rate);
				goto error;
		}
		/* FIXME @landswellsong always recording right now, filename is configuration option */
		audioroom->record = TRUE;
		char tmpfilename[512];
		guint64 ml = janus_get_monotonic_time();
		g_snprintf(tmpfilename, 512, cm_audioroom_settings.recording_pattern,
			audioroom->room_id, ml);
		audioroom->record_file = g_strdup(tmpfilename);

		// audioroom->record = FALSE;
		// if(record && json_is_true(record))
		// 	audioroom->record = TRUE;
		// if(recfile)
		// 	audioroom->record_file = g_strdup(json_string_value(recfile));
		audioroom->recording = NULL;
		audioroom->destroy = 0;
		audioroom->participants = g_hash_table_new(NULL, NULL);
		audioroom->destroyed = 0;
		janus_mutex_init(&audioroom->mutex);
		g_hash_table_insert(rooms, g_strdup(audioroom->room_id), audioroom);
		JANUS_LOG(LOG_VERB, "Created audioroom: %s (%s, %s, secret: %s, pin: %s)\n",
			audioroom->room_id, audioroom->room_name,
			audioroom->is_private ? "private" : "public",
			audioroom->room_secret ? audioroom->room_secret : "no secret",
			audioroom->room_pin ? audioroom->room_pin : "no pin");
		/* We need a thread for the mix */
		GError *error = NULL;
		audioroom->thread = g_thread_try_new("audioroom mixer thread", &cm_audioroom_mixer_thread, audioroom, &error);
		if(error != NULL) {
			janus_mutex_unlock(&rooms_mutex);
			JANUS_LOG(LOG_ERR, "Got error %d (%s) trying to launch the mixer thread...\n", error->code, error->message ? error->message : "??");
			error_code = CM_AUDIOROOM_ERROR_UNKNOWN_ERROR;
			g_snprintf(error_cause, 512, "Got error %d (%s) trying to launch the mixer thread", error->code, error->message ? error->message : "??");
			g_free(audioroom->room_id);
			g_free(audioroom->room_name);
			g_free(audioroom->room_secret);
			g_free(audioroom->record_file);
			g_hash_table_destroy(audioroom->participants);
			g_free(audioroom);
			goto error;
		} else {
			g_hash_table_insert(rooms, g_strdup(audioroom->room_id), audioroom);
		}
		/* Show updated rooms list */
		GHashTableIter iter;
		gpointer value;
		g_hash_table_iter_init(&iter, rooms);
		while (g_hash_table_iter_next(&iter, NULL, &value)) {
			cm_audioroom_room *ar = value;
			JANUS_LOG(LOG_VERB, "  ::: [%s][%s] %"SCNu32" (%s be recorded)\n",
				ar->room_id, ar->room_name, ar->sampling_rate, ar->record ? "will" : "will NOT");
		}
		janus_mutex_unlock(&rooms_mutex);
		/* Send info back */
		response = json_object();
		json_object_set_new(response, "audioroom", json_string("created"));
		json_object_set_new(response, "id", json_string(audioroom->room_id));
		goto plugin_response;
	} else if(!strcasecmp(request_text, "destroy")) {
		JANUS_LOG(LOG_VERB, "Attempt to destroy an existing audioroom room\n");
		json_t *room = json_object_get(root, "id");
		if(!room) {
			JANUS_LOG(LOG_ERR, "Missing element (room)\n");
			error_code = CM_AUDIOROOM_ERROR_MISSING_ELEMENT;
			g_snprintf(error_cause, 512, "Missing element (room)");
			goto error;
		}
		if(!json_is_string(room)) {
			JANUS_LOG(LOG_ERR, "Invalid element (room should be a string)\n");
			error_code = CM_AUDIOROOM_ERROR_INVALID_ELEMENT;
			g_snprintf(error_cause, 512, "Invalid element (room should be a string)");
			goto error;
		}
		const gchar *room_id = json_string_value(room);
		janus_mutex_lock(&rooms_mutex);
		cm_audioroom_room *audioroom = g_hash_table_lookup(rooms, room_id);
		if(audioroom == NULL) {
			janus_mutex_unlock(&rooms_mutex);
			JANUS_LOG(LOG_ERR, "No such room (%s)\n", room_id);
			error_code = CM_AUDIOROOM_ERROR_NO_SUCH_ROOM;
			g_snprintf(error_cause, 512, "No such room (%s)", room_id);
			goto error;
		}
		if(audioroom->room_secret) {
			/* A secret is required for this action */
			json_t *secret = json_object_get(root, "secret");
			if(!secret) {
				janus_mutex_unlock(&rooms_mutex);
				JANUS_LOG(LOG_ERR, "Missing element (secret)\n");
				error_code = CM_AUDIOROOM_ERROR_MISSING_ELEMENT;
				g_snprintf(error_cause, 512, "Missing element (secret)");
				goto error;
			}
			if(!json_is_string(secret)) {
				janus_mutex_unlock(&rooms_mutex);
				JANUS_LOG(LOG_ERR, "Invalid element (secret should be a string)\n");
				error_code = CM_AUDIOROOM_ERROR_INVALID_ELEMENT;
				g_snprintf(error_cause, 512, "Invalid element (secret should be a string)");
				goto error;
			}
			if(!janus_strcmp_const_time(audioroom->room_secret, json_string_value(secret))) {
				janus_mutex_unlock(&rooms_mutex);
				JANUS_LOG(LOG_ERR, "Unauthorized (wrong secret)\n");
				error_code = CM_AUDIOROOM_ERROR_UNAUTHORIZED;
				g_snprintf(error_cause, 512, "Unauthorized (wrong secret)");
				goto error;
			}
		}
		/* Remove room */
		g_hash_table_remove(rooms, GUINT_TO_POINTER(room_id));
		/* Prepare response/notification */
		response = json_object();
		json_object_set_new(response, "audioroom", json_string("destroyed"));
		json_object_set_new(response, "id", json_integer(room_id));
		char *response_text = json_dumps(response, JSON_INDENT(3) | JSON_PRESERVE_ORDER);
		/* Notify all participants that the fun is over, and that they'll be kicked */
		JANUS_LOG(LOG_VERB, "Notifying all participants\n");
		GHashTableIter iter;
		gpointer value;
		g_hash_table_iter_init(&iter, audioroom->participants);
		while (g_hash_table_iter_next(&iter, NULL, &value)) {
			cm_audioroom_participant *p = value;
			if(p && p->session) {
				p->room = NULL;
				int ret = gateway->push_event(p->session->handle, &cm_audioroom_plugin, NULL, response_text, NULL, NULL);
				JANUS_LOG(LOG_VERB, "  >> %d (%s)\n", ret, janus_get_api_error(ret));
				/* Get rid of queued packets */
				janus_mutex_lock(&p->qmutex);
				p->active = FALSE;
				while(p->inbuf) {
					GList *first = g_list_first(p->inbuf);
					cm_audioroom_rtp_relay_packet *pkt = (cm_audioroom_rtp_relay_packet *)first->data;
					p->inbuf = g_list_remove_link(p->inbuf, first);
					first = NULL;
					if(pkt == NULL)
						continue;
					if(pkt->data)
						g_free(pkt->data);
					pkt->data = NULL;
					g_free(pkt);
					pkt = NULL;
				}
				janus_mutex_unlock(&p->qmutex);
			}
		}
		g_free(response_text);
		janus_mutex_unlock(&rooms_mutex);
		JANUS_LOG(LOG_VERB, "Waiting for the mixer thread to complete...\n");
		audioroom->destroyed = janus_get_monotonic_time();
		g_thread_join(audioroom->thread);
		/* Done */
		JANUS_LOG(LOG_VERB, "Audiobridge room destroyed\n");
		goto plugin_response;
	} else if(!strcasecmp(request_text, "list")) {
		/* List all rooms (but private ones) and their details (except for the secret, of course...) */
		json_t *list = json_array();
		JANUS_LOG(LOG_VERB, "Request for the list for all video rooms\n");
		janus_mutex_lock(&rooms_mutex);
		GHashTableIter iter;
		gpointer value;
		g_hash_table_iter_init(&iter, rooms);
		while(g_hash_table_iter_next(&iter, NULL, &value)) {
			cm_audioroom_room *room = value;
			if(!room)
				continue;
			if(room->is_private) {
				/* Skip private room */
				JANUS_LOG(LOG_VERB, "Skipping private room '%s'\n", room->room_name);
				continue;
			}
			json_t *rl = json_object();
			json_object_set_new(rl, "id", json_integer(room->room_id));
			json_object_set_new(rl, "description", json_string(room->room_name));
			json_object_set_new(rl, "sampling_rate", json_integer(room->sampling_rate));
			json_object_set_new(rl, "record", json_string(room->record ? "true" : "false"));
			/* TODO: Possibly list participant details... or make it a separate API call for a specific room */
			json_object_set_new(rl, "num_participants", json_integer(g_hash_table_size(room->participants)));
			json_array_append_new(list, rl);
		}
		janus_mutex_unlock(&rooms_mutex);
		response = json_object();
		json_object_set_new(response, "audioroom", json_string("success"));
		json_object_set_new(response, "list", list);
		goto plugin_response;
	} else if(!strcasecmp(request_text, "exists")) {
		/* Check whether a given room exists or not, returns true/false */
		json_t *room = json_object_get(root, "id");
		if(!room) {
			JANUS_LOG(LOG_ERR, "Missing element (room)\n");
			error_code = CM_AUDIOROOM_ERROR_MISSING_ELEMENT;
			g_snprintf(error_cause, 512, "Missing element (room)");
			goto error;
		}
		if(!json_is_string(room)) {
			JANUS_LOG(LOG_ERR, "Invalid element (room should be a string)\n");
			error_code = CM_AUDIOROOM_ERROR_INVALID_ELEMENT;
			g_snprintf(error_cause, 512, "Invalid element (room should be a string)");
			goto error;
		}
		const gchar *room_id = json_string_value(room);
		janus_mutex_lock(&rooms_mutex);
		gboolean room_exists = g_hash_table_contains(rooms, room_id);
		janus_mutex_unlock(&rooms_mutex);
		response = json_object();
		json_object_set_new(response, "audioroom", json_string("success"));
		json_object_set_new(response, "id", json_string(room_id));
		json_object_set_new(response, "exists", json_string(room_exists ? "true" : "false"));
		goto plugin_response;
	} else if(!strcasecmp(request_text, "listparticipants")) {
		/* List all participants in a room */
		json_t *room = json_object_get(root, "id");
		if(!room) {
			JANUS_LOG(LOG_ERR, "Missing element (room)\n");
			error_code = CM_AUDIOROOM_ERROR_MISSING_ELEMENT;
			g_snprintf(error_cause, 512, "Missing element (room)");
			goto error;
		}
		if(!json_is_string(room)) {
			JANUS_LOG(LOG_ERR, "Invalid element (room should be a string)\n");
			error_code = CM_AUDIOROOM_ERROR_INVALID_ELEMENT;
			g_snprintf(error_cause, 512, "Invalid element (room should be a string)");
			goto error;
		}
		const gchar *room_id = json_string_value(room);
		janus_mutex_lock(&rooms_mutex);
		cm_audioroom_room *audioroom = g_hash_table_lookup(rooms, room_id);
		janus_mutex_unlock(&rooms_mutex);
		if(audioroom == NULL) {
			JANUS_LOG(LOG_ERR, "No such room (%s)\n", room_id);
			error_code = CM_AUDIOROOM_ERROR_NO_SUCH_ROOM;
			g_snprintf(error_cause, 512, "No such room (%s)", room_id);
			goto error;
		}
		if(audioroom->destroyed) {
			JANUS_LOG(LOG_ERR, "No such room (%s)\n", room_id);
			error_code = CM_AUDIOROOM_ERROR_NO_SUCH_ROOM;
			g_snprintf(error_cause, 512, "No such room (%s)", room_id);
			goto error;
		}
		/* Return a list of all participants */
		janus_mutex_lock(&audioroom->mutex);
		json_t *list = json_array();
		GHashTableIter iter;
		gpointer value;
		g_hash_table_iter_init(&iter, audioroom->participants);
		while (!audioroom->destroyed && g_hash_table_iter_next(&iter, NULL, &value)) {
			cm_audioroom_participant *p = value;
			json_t *pl = json_object();
			json_object_set_new(pl, "userid", json_integer(p->user_id));
			if(p->display)
				json_object_set_new(pl, "display", json_string(p->display));
			json_object_set_new(pl, "muted", json_string(p->muted ? "true" : "false"));
			json_array_append_new(list, pl);
		}
		janus_mutex_unlock(&audioroom->mutex);
		response = json_object();
		json_object_set_new(response, "audioroom", json_string("participants"));
		json_object_set_new(response, "id", json_string(room_id));
		json_object_set_new(response, "participants", list);
		goto plugin_response;
	} else if(!strcasecmp(request_text, "resetdecoder")) {
		/* Mark the Opus decoder for the participant invalid and recreate it */
		cm_audioroom_participant *participant = (cm_audioroom_participant *)session->participant;
		if(participant == NULL || participant->room == NULL) {
			JANUS_LOG(LOG_ERR, "Can't reset (not in a room)\n");
			error_code = CM_AUDIOROOM_ERROR_NOT_JOINED;
			g_snprintf(error_cause, 512, "Can't reset (not in a room)");
			goto error;
		}
		participant->reset = TRUE;
		response = json_object();
		json_object_set_new(response, "audioroom", json_string("success"));
		goto plugin_response;
	} else if(!strcasecmp(request_text, "join") || !strcasecmp(request_text, "configure")
			|| !strcasecmp(request_text, "changeroom") || !strcasecmp(request_text, "leave")) {
		/* These messages are handled asynchronously */
		cm_audioroom_message *msg = g_malloc0(sizeof(cm_audioroom_message));
		if(msg == NULL) {
			JANUS_LOG(LOG_FATAL, "Memory error!\n");
			error_code = CM_AUDIOROOM_ERROR_UNKNOWN_ERROR;
			g_snprintf(error_cause, 512, "Memory error");
			goto error;
		}

		g_free(message);
		msg->handle = handle;
		msg->transaction = transaction;
		msg->message = root;
		msg->sdp_type = sdp_type;
		msg->sdp = sdp;

		g_async_queue_push(messages, msg);

		return janus_plugin_result_new(JANUS_PLUGIN_OK_WAIT, NULL);
	} else {
		JANUS_LOG(LOG_VERB, "Unknown request '%s'\n", request_text);
		error_code = CM_AUDIOROOM_ERROR_INVALID_REQUEST;
		g_snprintf(error_cause, 512, "Unknown request '%s'", request_text);
		goto error;
	}

plugin_response:
		{
			if (!response) {
				error_code = CM_AUDIOROOM_ERROR_UNKNOWN_ERROR;
				g_snprintf(error_cause, 512, "Invalid response");
				goto error;
			}
			if(root != NULL)
				json_decref(root);
			g_free(transaction);
			g_free(message);
			g_free(sdp_type);
			g_free(sdp);

			char *response_text = json_dumps(response, JSON_INDENT(3) | JSON_PRESERVE_ORDER);
			json_decref(response);
			janus_plugin_result *result = janus_plugin_result_new(JANUS_PLUGIN_OK, response_text);
			g_free(response_text);
			return result;
		}

error:
		{
			if(root != NULL)
				json_decref(root);
			g_free(transaction);
			g_free(message);
			g_free(sdp_type);
			g_free(sdp);

			/* Prepare JSON error event */
			json_t *event = json_object();
			json_object_set_new(event, "audioroom", json_string("event"));
			json_object_set_new(event, "error_code", json_integer(error_code));
			json_object_set_new(event, "error", json_string(error_cause));
			char *event_text = json_dumps(event, JSON_INDENT(3) | JSON_PRESERVE_ORDER);
			json_decref(event);
			janus_plugin_result *result = janus_plugin_result_new(JANUS_PLUGIN_OK, event_text);
			g_free(event_text);
			return result;
		}

}

void cm_audioroom_setup_media(janus_plugin_session *handle) {
	JANUS_LOG(LOG_INFO, "WebRTC media is now available\n");
	if(g_atomic_int_get(&stopping) || !g_atomic_int_get(&initialized))
		return;
	cm_audioroom_session *session = (cm_audioroom_session *)handle->plugin_handle;
	if(!session) {
		JANUS_LOG(LOG_ERR, "No session associated with this handle...\n");
		return;
	}
	if(session->destroyed)
		return;
	cm_audioroom_participant *participant = (cm_audioroom_participant *)session->participant;
	if(!participant)
		return;
	g_atomic_int_set(&session->hangingup, 0);
	/* FIXME Only send this peer the audio mix when we get this event */
	session->started = TRUE;
}

void cm_audioroom_incoming_rtp(janus_plugin_session *handle, int video, char *buf, int len) {
	if(handle == NULL || handle->stopped || g_atomic_int_get(&stopping) || !g_atomic_int_get(&initialized))
		return;
	cm_audioroom_session *session = (cm_audioroom_session *)handle->plugin_handle;
	if(!session || session->destroyed || session->stopping || !session->participant)
		return;
	cm_audioroom_participant *participant = (cm_audioroom_participant *)session->participant;
	if(!participant->active || participant->muted || !participant->decoder || !participant->room)
		return;
	if(participant->active && participant->decoder) {
		/* First of all, check if a reset on the decoder is due */
		if(participant->reset) {
			/* Create a new decoder and get rid of the old one */
			int error = 0;
			OpusDecoder *decoder = opus_decoder_create(participant->room->sampling_rate, 1, &error);
			if(error != OPUS_OK) {
				JANUS_LOG(LOG_ERR, "Error resetting Opus decoder...\n");
			} else {
				if(participant->decoder)
					opus_decoder_destroy(participant->decoder);
				participant->decoder = decoder;
				JANUS_LOG(LOG_VERB, "Opus decoder reset\n");
			}
			participant->reset = FALSE;
		}
		/* Decode frame (Opus -> slinear) */
		rtp_header *rtp = (rtp_header *)buf;
		cm_audioroom_rtp_relay_packet *pkt = g_malloc0(sizeof(cm_audioroom_rtp_relay_packet));
		if(pkt == NULL) {
			JANUS_LOG(LOG_FATAL, "Memory error!\n");
			return;
		}
		pkt->data = g_malloc0(BUFFER_SAMPLES*sizeof(opus_int16));
		if(pkt->data == NULL) {
			JANUS_LOG(LOG_FATAL, "Memory error!\n");
			g_free(pkt);
			return;
		}
		pkt->ssrc = 0;
		pkt->timestamp = ntohl(rtp->timestamp);
		pkt->seq_number = ntohs(rtp->seq_number);
		participant->working = TRUE;
		pkt->length = opus_decode(participant->decoder, (const unsigned char *)buf+12, len-12, (opus_int16 *)pkt->data, BUFFER_SAMPLES, USE_FEC);
		participant->working = FALSE;
		if(pkt->length < 0) {
			JANUS_LOG(LOG_ERR, "[Opus] Ops! got an error decoding the Opus frame: %d (%s)\n", pkt->length, opus_strerror(pkt->length));
			g_free(pkt->data);
			g_free(pkt);
			return;
		}
		/* Enqueue the decoded frame */
		janus_mutex_lock(&participant->qmutex);
		/* Insert packets sorting by sequence number */
		participant->inbuf = g_list_insert_sorted(participant->inbuf, pkt, &cm_audioroom_rtp_sort);
		if(participant->prebuffering) {
			/* Still pre-buffering: do we have enough packets now? */
			if(g_list_length(participant->inbuf) == DEFAULT_PREBUFFERING) {
				participant->prebuffering = FALSE;
				JANUS_LOG(LOG_VERB, "Prebuffering done! Finally adding the user to the mix\n");
			} else {
				JANUS_LOG(LOG_VERB, "Still prebuffering (got %d packets), not adding the user to the mix yet\n", g_list_length(participant->inbuf));
			}
		} else {
			/* Make sure we're not queueing too many packets: if so, get rid of the older ones */
			if(g_list_length(participant->inbuf) >= DEFAULT_PREBUFFERING*2) {
				JANUS_LOG(LOG_WARN, "Too many packets in queue (%d > %d), removing older ones\n",
					g_list_length(participant->inbuf), DEFAULT_PREBUFFERING*2);
				while(g_list_length(participant->inbuf) > DEFAULT_PREBUFFERING*2) {
					/* Remove this packet: it's too old */
					GList *first = g_list_first(participant->inbuf);
					cm_audioroom_rtp_relay_packet *pkt = (cm_audioroom_rtp_relay_packet *)first->data;
					participant->inbuf = g_list_remove_link(participant->inbuf, first);
					first = NULL;
					if(pkt == NULL)
						continue;
					if(pkt->data)
						g_free(pkt->data);
					pkt->data = NULL;
					g_free(pkt);
					pkt = NULL;
				}
			}
		}
		janus_mutex_unlock(&participant->qmutex);
	}
}

void cm_audioroom_incoming_rtcp(janus_plugin_session *handle, int video, char *buf, int len) {
	if(handle == NULL || handle->stopped || g_atomic_int_get(&stopping) || !g_atomic_int_get(&initialized))
		return;
	/* FIXME Should we care? */
}

void cm_audioroom_hangup_media(janus_plugin_session *handle) {
	JANUS_LOG(LOG_INFO, "No WebRTC media anymore\n");
	if(g_atomic_int_get(&stopping) || !g_atomic_int_get(&initialized))
		return;
	cm_audioroom_session *session = (cm_audioroom_session *)handle->plugin_handle;
	if(!session) {
		JANUS_LOG(LOG_ERR, "No session associated with this handle...\n");
		return;
	}
	session->started = FALSE;
	if(session->destroyed || !session->participant)
		return;
	if(g_atomic_int_add(&session->hangingup, 1))
		return;
	/* Get rid of participant */
	cm_audioroom_participant *participant = (cm_audioroom_participant *)session->participant;
	cm_audioroom_room *audioroom = participant->room;
	if(audioroom != NULL) {
		janus_mutex_lock(&audioroom->mutex);
		json_t *event = json_object();
		json_object_set_new(event, "audioroom", json_string("event"));
		json_object_set_new(event, "id", json_string(audioroom->room_id));
		json_object_set_new(event, "leaving", json_integer(participant->user_id));
		char *leaving_text = json_dumps(event, JSON_INDENT(3) | JSON_PRESERVE_ORDER);
		json_decref(event);
		g_hash_table_remove(audioroom->participants, GUINT_TO_POINTER(participant->user_id));
		GHashTableIter iter;
		gpointer value;
		g_hash_table_iter_init(&iter, audioroom->participants);
		while (g_hash_table_iter_next(&iter, NULL, &value)) {
			cm_audioroom_participant *p = value;
			if(p == participant) {
				continue;	/* Skip the leaving participant itself */
			}
			JANUS_LOG(LOG_VERB, "Notifying participant %"SCNu64" (%s)\n", p->user_id, p->display ? p->display : "??");
			int ret = gateway->push_event(p->session->handle, &cm_audioroom_plugin, NULL, leaving_text, NULL, NULL);
			JANUS_LOG(LOG_VERB, "  >> %d (%s)\n", ret, janus_get_api_error(ret));
		}
		g_free(leaving_text);
	}
	/* Free the participant resources */
	janus_mutex_lock(&participant->qmutex);
	participant->active = FALSE;
	participant->muted = TRUE;
	if(participant->display)
		g_free(participant->display);
	participant->display = NULL;
	participant->prebuffering = TRUE;
	/* Make sure we're not using the encoder/decoder right now, we're going to destroy them */
	while(participant->working)
		g_usleep(5000);
	if(participant->encoder)
		opus_encoder_destroy(participant->encoder);
	participant->encoder = NULL;
	if(participant->decoder)
		opus_decoder_destroy(participant->decoder);
	participant->decoder = NULL;
	participant->reset = FALSE;
	/* Get rid of queued packets */
	while(participant->inbuf) {
		GList *first = g_list_first(participant->inbuf);
		cm_audioroom_rtp_relay_packet *pkt = (cm_audioroom_rtp_relay_packet *)first->data;
		participant->inbuf = g_list_remove_link(participant->inbuf, first);
		first = NULL;
		if(pkt == NULL)
			continue;
		if(pkt->data)
			g_free(pkt->data);
		pkt->data = NULL;
		g_free(pkt);
		pkt = NULL;
	}
	janus_mutex_unlock(&participant->qmutex);
	if(audioroom != NULL) {
		janus_mutex_unlock(&audioroom->mutex);
	}
}

/* Thread to handle incoming messages */
static void *cm_audioroom_handler(void *data) {
	JANUS_LOG(LOG_VERB, "Joining AudioBridge handler thread\n");
	cm_audioroom_message *msg = NULL;
	int error_code = 0;
	char *error_cause = g_malloc0(512);
	if(error_cause == NULL) {
		JANUS_LOG(LOG_FATAL, "Memory error!\n");
		return NULL;
	}
	json_t *root = NULL;
	while(g_atomic_int_get(&initialized) && !g_atomic_int_get(&stopping)) {
		if(!messages || (msg = g_async_queue_try_pop(messages)) == NULL) {
			usleep(50000);
			continue;
		}
		cm_audioroom_session *session = (cm_audioroom_session *)msg->handle->plugin_handle;
		if(!session) {
			JANUS_LOG(LOG_ERR, "No session associated with this handle...\n");
			cm_audioroom_message_free(msg);
			continue;
		}
		if(session->destroyed) {
			cm_audioroom_message_free(msg);
			continue;
		}
		/* Handle request */
		error_code = 0;
		root = NULL;
		if(msg->message == NULL) {
			JANUS_LOG(LOG_ERR, "No message??\n");
			error_code = CM_AUDIOROOM_ERROR_NO_MESSAGE;
			g_snprintf(error_cause, 512, "%s", "No message??");
			goto error;
		}
		root = msg->message;
		/* Get the request first */
		json_t *request = json_object_get(root, "request");
		if(!request) {
			JANUS_LOG(LOG_ERR, "Missing element (request)\n");
			error_code = CM_AUDIOROOM_ERROR_MISSING_ELEMENT;
			g_snprintf(error_cause, 512, "Missing element (request)");
			goto error;
		}
		if(!json_is_string(request)) {
			JANUS_LOG(LOG_ERR, "Invalid element (request should be a string)\n");
			error_code = CM_AUDIOROOM_ERROR_INVALID_ELEMENT;
			g_snprintf(error_cause, 512, "Invalid element (request should be a string)");
			goto error;
		}
		const char *request_text = json_string_value(request);
		json_t *event = NULL;
		if(!strcasecmp(request_text, "join")) {
			JANUS_LOG(LOG_VERB, "Configuring new participant\n");
			cm_audioroom_participant *participant = session->participant;
			if(participant != NULL && participant->room != NULL) {
				JANUS_LOG(LOG_ERR, "Already in a room (use changeroom to join another one)\n");
				error_code = CM_AUDIOROOM_ERROR_ALREADY_JOINED;
				g_snprintf(error_cause, 512, "Already in a room (use changeroom to join another one)");
				goto error;
			}
			json_t *room = json_object_get(root, "id");
			if(!room) {
				JANUS_LOG(LOG_ERR, "Missing element (room)\n");
				error_code = CM_AUDIOROOM_ERROR_MISSING_ELEMENT;
				g_snprintf(error_cause, 512, "Missing element (room)");
				goto error;
			}
			if(!json_is_string(room)) {
				JANUS_LOG(LOG_ERR, "Invalid element (room should be a string)\n");
				error_code = CM_AUDIOROOM_ERROR_INVALID_ELEMENT;
				g_snprintf(error_cause, 512, "Invalid element (room should be a string)");
				goto error;
			}
			const gchar *room_id = json_string_value(room);
			janus_mutex_lock(&rooms_mutex);
			cm_audioroom_room *audioroom = g_hash_table_lookup(rooms, room_id);
			if(audioroom == NULL) {
				janus_mutex_unlock(&rooms_mutex);
				JANUS_LOG(LOG_ERR, "No such room (%s)\n", room_id);
				error_code = CM_AUDIOROOM_ERROR_NO_SUCH_ROOM;
				g_snprintf(error_cause, 512, "No such room (%s)", room_id);
				goto error;
			}
			if(audioroom->room_pin) {
				/* A PIN is required to join this room */
				json_t *pin = json_object_get(root, "pin");
				if(!pin) {
					janus_mutex_unlock(&rooms_mutex);
					JANUS_LOG(LOG_ERR, "Missing element (pin)\n");
					error_code = CM_AUDIOROOM_ERROR_MISSING_ELEMENT;
					g_snprintf(error_cause, 512, "Missing element (pin)");
					goto error;
				}
				if(!json_is_string(pin)) {
					janus_mutex_unlock(&rooms_mutex);
					JANUS_LOG(LOG_ERR, "Invalid element (pin should be a string)\n");
					error_code = CM_AUDIOROOM_ERROR_INVALID_ELEMENT;
					g_snprintf(error_cause, 512, "Invalid element (pin should be a string)");
					goto error;
				}
				if(!janus_strcmp_const_time(audioroom->room_pin, json_string_value(pin))) {
					janus_mutex_unlock(&rooms_mutex);
					JANUS_LOG(LOG_ERR, "Unauthorized (wrong pin)\n");
					error_code = CM_AUDIOROOM_ERROR_UNAUTHORIZED;
					g_snprintf(error_cause, 512, "Unauthorized (wrong pin)");
					goto error;
				}
			}
			janus_mutex_unlock(&rooms_mutex);
			json_t *display = json_object_get(root, "display");
			if(display && !json_is_string(display)) {
				JANUS_LOG(LOG_ERR, "Invalid element (display should be a string)\n");
				error_code = CM_AUDIOROOM_ERROR_INVALID_ELEMENT;
				g_snprintf(error_cause, 512, "Invalid element (display should be a string)");
				goto error;
			}
			const char *display_text = display ? json_string_value(display) : NULL;
			json_t *muted = json_object_get(root, "muted");
			if(muted && !json_is_boolean(muted)) {
				JANUS_LOG(LOG_ERR, "Invalid element (muted should be a boolean)\n");
				error_code = CM_AUDIOROOM_ERROR_INVALID_ELEMENT;
				g_snprintf(error_cause, 512, "Invalid element (muted should be a boolean)");
				goto error;
			}
			json_t *quality = json_object_get(root, "quality");
			if(quality && (!json_is_integer(quality) || json_integer_value(quality) < 0)) {
				JANUS_LOG(LOG_ERR, "Invalid element (quality should be a positive integer)\n");
				error_code = CM_AUDIOROOM_ERROR_INVALID_ELEMENT;
				g_snprintf(error_cause, 512, "Invalid element (quality should be a positive integer)");
				goto error;
			}
			int complexity = quality ? json_integer_value(quality) : DEFAULT_COMPLEXITY;
			if(complexity < 1 || complexity > 10) {
				JANUS_LOG(LOG_ERR, "Invalid element (quality should be a positive integer between 1 and 10)\n");
				error_code = CM_AUDIOROOM_ERROR_INVALID_ELEMENT;
				g_snprintf(error_cause, 512, "Invalid element (quality should be a positive integer between 1 and 10)");
				goto error;
			}
			guint64 user_id = 0;
			json_t *id = json_object_get(root, "userid");
			if(id) {
				if(!json_is_integer(id) || json_integer_value(id) < 0) {
					JANUS_LOG(LOG_ERR, "Invalid element (id should be a positive integer)\n");
					error_code = CM_AUDIOROOM_ERROR_INVALID_ELEMENT;
					g_snprintf(error_cause, 512, "Invalid element (id should be a positive integer)");
					goto error;
				}
				user_id = json_integer_value(id);
				if(g_hash_table_lookup(audioroom->participants, GUINT_TO_POINTER(user_id)) != NULL) {
					/* User ID already taken */
					JANUS_LOG(LOG_ERR, "User ID %"SCNu64" already exists\n", user_id);
					error_code = CM_AUDIOROOM_ERROR_ID_EXISTS;
					g_snprintf(error_cause, 512, "User ID %"SCNu64" already exists", user_id);
					goto error;
				}
			}
			if(user_id == 0) {
				/* Generate a random ID */
				while(user_id == 0) {
					user_id = g_random_int();
					if(g_hash_table_lookup(audioroom->participants, GUINT_TO_POINTER(user_id)) != NULL) {
						/* User ID already taken, try another one */
						user_id = 0;
					}
				}
			}
			JANUS_LOG(LOG_VERB, "  -- Participant ID: %"SCNu64"\n", user_id);
			if(participant == NULL) {
				participant = g_malloc0(sizeof(cm_audioroom_participant));
				if(participant == NULL) {
					JANUS_LOG(LOG_FATAL, "Memory error!\n");
					error_code = CM_AUDIOROOM_ERROR_UNKNOWN_ERROR;
					g_snprintf(error_cause, 512, "Memory error");
					goto error;
				}
				participant->active = FALSE;
				participant->prebuffering = TRUE;
				participant->display = NULL;
				participant->inbuf = NULL;
				participant->outbuf = NULL;
				participant->encoder = NULL;
				participant->decoder = NULL;
				participant->reset = FALSE;
				janus_mutex_init(&participant->qmutex);
			}
			participant->session = session;
			participant->room = audioroom;
			participant->user_id = user_id;
			if(participant->display != NULL)
				g_free(participant->display);
			participant->display = display_text ? g_strdup(display_text) : NULL;
			participant->muted = muted ? json_is_true(muted) : FALSE;	/* By default, everyone's unmuted when joining */
			participant->opus_complexity = complexity;
			if(participant->outbuf == NULL)
				participant->outbuf = g_async_queue_new();
			participant->active = session->started;
			if(!session->started) {
				/* Initialize the RTP context only if we're renegotiating */
				participant->context.a_last_ssrc = 0;
				participant->context.a_last_ts = 0;
				participant->context.a_base_ts = 0;
				participant->context.a_base_ts_prev = 0;
				participant->context.a_last_seq = 0;
				participant->context.a_base_seq = 0;
				participant->context.a_base_seq_prev = 0;
				participant->opus_pt = 0;
			}
			JANUS_LOG(LOG_VERB, "Creating Opus encoder/decoder (sampling rate %d)\n", audioroom->sampling_rate);
			/* Opus encoder */
			int error = 0;
			if(participant->encoder == NULL) {
				participant->encoder = opus_encoder_create(audioroom->sampling_rate, 1, OPUS_APPLICATION_VOIP, &error);
				if(error != OPUS_OK) {
					if(participant->display)
						g_free(participant->display);
					g_free(participant);
					JANUS_LOG(LOG_ERR, "Error creating Opus encoder\n");
					error_code = CM_AUDIOROOM_ERROR_LIBOPUS_ERROR;
					g_snprintf(error_cause, 512, "Error creating Opus decoder");
					goto error;
				}
				if(audioroom->sampling_rate == 8000) {
					opus_encoder_ctl(participant->encoder, OPUS_SET_MAX_BANDWIDTH(OPUS_BANDWIDTH_NARROWBAND));
				} else if(audioroom->sampling_rate == 12000) {
					opus_encoder_ctl(participant->encoder, OPUS_SET_MAX_BANDWIDTH(OPUS_BANDWIDTH_MEDIUMBAND));
				} else if(audioroom->sampling_rate == 16000) {
					opus_encoder_ctl(participant->encoder, OPUS_SET_MAX_BANDWIDTH(OPUS_BANDWIDTH_WIDEBAND));
				} else if(audioroom->sampling_rate == 24000) {
					opus_encoder_ctl(participant->encoder, OPUS_SET_MAX_BANDWIDTH(OPUS_BANDWIDTH_SUPERWIDEBAND));
				} else if(audioroom->sampling_rate == 48000) {
					opus_encoder_ctl(participant->encoder, OPUS_SET_MAX_BANDWIDTH(OPUS_BANDWIDTH_FULLBAND));
				} else {
					JANUS_LOG(LOG_WARN, "Unsupported sampling rate %d, setting 16kHz\n", audioroom->sampling_rate);
					audioroom->sampling_rate = 16000;
					opus_encoder_ctl(participant->encoder, OPUS_SET_MAX_BANDWIDTH(OPUS_BANDWIDTH_WIDEBAND));
				}
				/* FIXME This settings should be configurable */
				opus_encoder_ctl(participant->encoder, OPUS_SET_INBAND_FEC(USE_FEC));
			}
			opus_encoder_ctl(participant->encoder, OPUS_SET_COMPLEXITY(participant->opus_complexity));
			if(participant->decoder == NULL) {
				/* Opus decoder */
				error = 0;
				participant->decoder = opus_decoder_create(audioroom->sampling_rate, 1, &error);
				if(error != OPUS_OK) {
					if(participant->display)
						g_free(participant->display);
					if(participant->encoder)
						opus_encoder_destroy(participant->encoder);
					participant->encoder = NULL;
					if(participant->decoder)
						opus_decoder_destroy(participant->decoder);
					participant->decoder = NULL;
					g_free(participant);
					JANUS_LOG(LOG_ERR, "Error creating Opus encoder\n");
					error_code = CM_AUDIOROOM_ERROR_LIBOPUS_ERROR;
					g_snprintf(error_cause, 512, "Error creating Opus decoder");
					goto error;
				}
			}
			participant->reset = FALSE;
			/* Finally, start the encoding thread if it hasn't already */
			if(participant->thread == NULL) {
				GError *error = NULL;
				participant->thread = g_thread_try_new("audioroom participant thread", &cm_audioroom_participant_thread, participant, &error);
				if(error != NULL) {
					/* FIXME We should fail here... */
					JANUS_LOG(LOG_ERR, "Got error %d (%s) trying to launch the participant thread...\n", error->code, error->message ? error->message : "??");
				}
			}

			/* Done */
			janus_mutex_lock(&audioroom->mutex);
			session->participant = participant;
			g_hash_table_insert(audioroom->participants, GUINT_TO_POINTER(user_id), participant);
			/* Notify the other participants */
			json_t *newuser = json_object();
			json_object_set_new(newuser, "audioroom", json_string("joined"));
			json_object_set_new(newuser, "id", json_string(audioroom->room_id));
			json_t *newuserlist = json_array();
			json_t *pl = json_object();
			json_object_set_new(pl, "userid", json_integer(participant->user_id));
			if(participant->display)
				json_object_set_new(pl, "display", json_string(participant->display));
			json_object_set_new(pl, "muted", json_string(participant->muted ? "true" : "false"));
			json_array_append_new(newuserlist, pl);
			json_object_set_new(newuser, "participants", newuserlist);
			char *newuser_text = json_dumps(newuser, JSON_INDENT(3) | JSON_PRESERVE_ORDER);
			json_decref(newuser);
			GHashTableIter iter;
			gpointer value;
			g_hash_table_iter_init(&iter, audioroom->participants);
			while (g_hash_table_iter_next(&iter, NULL, &value)) {
				cm_audioroom_participant *p = value;
				if(p == participant) {
					continue;
				}
				JANUS_LOG(LOG_VERB, "Notifying participant %"SCNu64" (%s)\n", p->user_id, p->display ? p->display : "??");
				int ret = gateway->push_event(p->session->handle, &cm_audioroom_plugin, NULL, newuser_text, NULL, NULL);
				JANUS_LOG(LOG_VERB, "  >> %d (%s)\n", ret, janus_get_api_error(ret));
			}
			g_free(newuser_text);
			/* Return a list of all available participants for the new participant now */
			json_t *list = json_array();
			g_hash_table_iter_init(&iter, audioroom->participants);
			while (g_hash_table_iter_next(&iter, NULL, &value)) {
				cm_audioroom_participant *p = value;
				if(p == participant) {
					continue;
				}
				json_t *pl = json_object();
				json_object_set_new(pl, "userid", json_integer(p->user_id));
				if(p->display)
					json_object_set_new(pl, "display", json_string(p->display));
				json_object_set_new(pl, "muted", json_string(p->muted ? "true" : "false"));
				json_array_append_new(list, pl);
			}
			event = json_object();
			json_object_set_new(event, "audioroom", json_string("joined"));
			json_object_set_new(event, "id", json_string(audioroom->room_id));
			json_object_set_new(event, "userid", json_integer(user_id));
			json_object_set_new(event, "participants", list);
			janus_mutex_unlock(&audioroom->mutex);
		} else if(!strcasecmp(request_text, "configure")) {
			/* Handle this participant */
			cm_audioroom_participant *participant = (cm_audioroom_participant *)session->participant;
			if(participant == NULL || participant->room == NULL) {
				JANUS_LOG(LOG_ERR, "Can't configure (not in a room)\n");
				error_code = CM_AUDIOROOM_ERROR_NOT_JOINED;
				g_snprintf(error_cause, 512, "Can't configure (not in a room)");
				goto error;
			}
			/* Configure settings for this participant */
			json_t *muted = json_object_get(root, "muted");
			if(muted && !json_is_boolean(muted)) {
				JANUS_LOG(LOG_ERR, "Invalid element (muted should be a boolean)\n");
				error_code = CM_AUDIOROOM_ERROR_INVALID_ELEMENT;
				g_snprintf(error_cause, 512, "Invalid element (muted should be a boolean)");
				goto error;
			}
			json_t *quality = json_object_get(root, "quality");
			if(quality && (!json_is_integer(quality) || json_integer_value(quality) < 0)) {
				JANUS_LOG(LOG_ERR, "Invalid element (quality should be a positive integer)\n");
				error_code = CM_AUDIOROOM_ERROR_INVALID_ELEMENT;
				g_snprintf(error_cause, 512, "Invalid element (quality should be a positive integer)");
				goto error;
			}
			if(quality) {
				int complexity = quality ? json_integer_value(quality) : DEFAULT_COMPLEXITY;
				if(complexity < 1 || complexity > 10) {
					JANUS_LOG(LOG_ERR, "Invalid element (quality should be a positive integer between 1 and 10)\n");
					error_code = CM_AUDIOROOM_ERROR_INVALID_ELEMENT;
					g_snprintf(error_cause, 512, "Invalid element (quality should be a positive integer between 1 and 10)");
					goto error;
				}
				participant->opus_complexity = complexity;
				if(participant->encoder)
					opus_encoder_ctl(participant->encoder, OPUS_SET_COMPLEXITY(participant->opus_complexity));
			}
			if(muted) {
				participant->muted = json_is_true(muted);
				JANUS_LOG(LOG_VERB, "Setting muted property: %s (room %s, user %"SCNu64")\n", participant->muted ? "true" : "false", participant->room->room_id, participant->user_id);
				if(participant->muted) {
					/* Clear the queued packets waiting to be handled */
					janus_mutex_lock(&participant->qmutex);
					while(participant->inbuf) {
						GList *first = g_list_first(participant->inbuf);
						cm_audioroom_rtp_relay_packet *pkt = (cm_audioroom_rtp_relay_packet *)first->data;
						participant->inbuf = g_list_remove_link(participant->inbuf, first);
						first = NULL;
						if(pkt == NULL)
							continue;
						if(pkt->data)
							g_free(pkt->data);
						pkt->data = NULL;
						g_free(pkt);
						pkt = NULL;
					}
					janus_mutex_unlock(&participant->qmutex);
				}
				/* Notify all other participants about the mute/unmute */
				cm_audioroom_room *audioroom = participant->room;
				janus_mutex_lock(&audioroom->mutex);
				json_t *list = json_array();
				json_t *pl = json_object();
				json_object_set_new(pl, "userid", json_integer(participant->user_id));
				if(participant->display)
					json_object_set_new(pl, "display", json_string(participant->display));
				json_object_set_new(pl, "muted", json_string(participant->muted ? "true" : "false"));
				json_array_append_new(list, pl);
				json_t *pub = json_object();
				json_object_set_new(pub, "audioroom", json_string("event"));
				json_object_set_new(pub, "id", json_string(participant->room->room_id));
				json_object_set_new(pub, "participants", list);
				char *pub_text = json_dumps(pub, JSON_INDENT(3) | JSON_PRESERVE_ORDER);
				json_decref(pub);
				GHashTableIter iter;
				gpointer value;
				g_hash_table_iter_init(&iter, audioroom->participants);
				while (g_hash_table_iter_next(&iter, NULL, &value)) {
					cm_audioroom_participant *p = value;
					if(p == participant) {
						continue;	/* Skip the new participant itself */
					}
					JANUS_LOG(LOG_VERB, "Notifying participant %"SCNu64" (%s)\n", p->user_id, p->display ? p->display : "??");
					int ret = gateway->push_event(p->session->handle, &cm_audioroom_plugin, NULL, pub_text, NULL, NULL);
					JANUS_LOG(LOG_VERB, "  >> %d (%s)\n", ret, janus_get_api_error(ret));
				}
				g_free(pub_text);
				janus_mutex_unlock(&audioroom->mutex);
			}
			/* Done */
			event = json_object();
			json_object_set_new(event, "audioroom", json_string("event"));
			json_object_set_new(event, "id", json_string(participant->room->room_id));
			json_object_set_new(event, "result", json_string("ok"));
		} else if(!strcasecmp(request_text, "changeroom")) {
			/* The participant wants to leave the current room and join another one without reconnecting (e.g., a sidebar) */
			cm_audioroom_participant *participant = (cm_audioroom_participant *)session->participant;
			if(participant == NULL || participant->room == NULL) {
				JANUS_LOG(LOG_ERR, "Can't change room (not in a room in the first place)\n");
				error_code = CM_AUDIOROOM_ERROR_NOT_JOINED;
				g_snprintf(error_cause, 512, "Can't change room (not in a room in the first place");
				goto error;
			}
			json_t *room = json_object_get(root, "id");
			if(!room) {
				JANUS_LOG(LOG_ERR, "Missing element (room)\n");
				error_code = CM_AUDIOROOM_ERROR_MISSING_ELEMENT;
				g_snprintf(error_cause, 512, "Missing element (room)");
				goto error;
			}
			if(!json_is_string(room)) {
				JANUS_LOG(LOG_ERR, "Invalid element (room should be a string)\n");
				error_code = CM_AUDIOROOM_ERROR_INVALID_ELEMENT;
				g_snprintf(error_cause, 512, "Invalid element (room should be a string)");
				goto error;
			}
			const gchar *room_id = json_string_value(room);
			janus_mutex_lock(&rooms_mutex);
			cm_audioroom_room *audioroom = g_hash_table_lookup(rooms, room_id);
			if(audioroom == NULL) {
				janus_mutex_unlock(&rooms_mutex);
				JANUS_LOG(LOG_ERR, "No such room (%s)\n", room_id);
				error_code = CM_AUDIOROOM_ERROR_NO_SUCH_ROOM;
				g_snprintf(error_cause, 512, "No such room (%s)", room_id);
				goto error;
			}
			if(audioroom->room_pin) {
				/* A PIN is required to join this room */
				json_t *pin = json_object_get(root, "pin");
				if(!pin) {
					janus_mutex_unlock(&rooms_mutex);
					JANUS_LOG(LOG_ERR, "Missing element (pin)\n");
					error_code = CM_AUDIOROOM_ERROR_MISSING_ELEMENT;
					g_snprintf(error_cause, 512, "Missing element (pin)");
					goto error;
				}
				if(!json_is_string(pin)) {
					janus_mutex_unlock(&rooms_mutex);
					JANUS_LOG(LOG_ERR, "Invalid element (pin should be a string)\n");
					error_code = CM_AUDIOROOM_ERROR_INVALID_ELEMENT;
					g_snprintf(error_cause, 512, "Invalid element (pin should be a string)");
					goto error;
				}
				if(!janus_strcmp_const_time(audioroom->room_pin, json_string_value(pin))) {
					janus_mutex_unlock(&rooms_mutex);
					JANUS_LOG(LOG_ERR, "Unauthorized (wrong pin)\n");
					error_code = CM_AUDIOROOM_ERROR_UNAUTHORIZED;
					g_snprintf(error_cause, 512, "Unauthorized (wrong pin)");
					goto error;
				}
			}
			janus_mutex_unlock(&rooms_mutex);
			json_t *display = json_object_get(root, "display");
			if(display && !json_is_string(display)) {
				JANUS_LOG(LOG_ERR, "Invalid element (display should be a string)\n");
				error_code = CM_AUDIOROOM_ERROR_INVALID_ELEMENT;
				g_snprintf(error_cause, 512, "Invalid element (display should be a string)");
				goto error;
			}
			const char *display_text = display ? json_string_value(display) : NULL;
			json_t *muted = json_object_get(root, "muted");
			if(muted && !json_is_boolean(muted)) {
				JANUS_LOG(LOG_ERR, "Invalid element (muted should be a boolean)\n");
				error_code = CM_AUDIOROOM_ERROR_INVALID_ELEMENT;
				g_snprintf(error_cause, 512, "Invalid element (muted should be a boolean)");
				goto error;
			}
			json_t *quality = json_object_get(root, "quality");
			if(quality && (!json_is_integer(quality) || json_integer_value(quality) < 0)) {
				JANUS_LOG(LOG_ERR, "Invalid element (quality should be a positive integer)\n");
				error_code = CM_AUDIOROOM_ERROR_INVALID_ELEMENT;
				g_snprintf(error_cause, 512, "Invalid element (quality should be a positive integer)");
				goto error;
			}
			int complexity = quality ? json_integer_value(quality) : DEFAULT_COMPLEXITY;
			if(complexity < 1 || complexity > 10) {
				JANUS_LOG(LOG_ERR, "Invalid element (quality should be a positive integer between 1 and 10)\n");
				error_code = CM_AUDIOROOM_ERROR_INVALID_ELEMENT;
				g_snprintf(error_cause, 512, "Invalid element (quality should be a positive integer between 1 and 10)");
				goto error;
			}
			guint64 user_id = 0;
			json_t *id = json_object_get(root, "userid");
			if(id) {
				if(!json_is_integer(id) || json_integer_value(id) < 0) {
					JANUS_LOG(LOG_ERR, "Invalid element (id should be a positive integer)\n");
					error_code = CM_AUDIOROOM_ERROR_INVALID_ELEMENT;
					g_snprintf(error_cause, 512, "Invalid element (id should be a positive integer)");
					goto error;
				}
				user_id = json_integer_value(id);
				if(g_hash_table_lookup(audioroom->participants, GUINT_TO_POINTER(user_id)) != NULL) {
					/* User ID already taken */
					JANUS_LOG(LOG_ERR, "User ID %"SCNu64" already exists\n", user_id);
					error_code = CM_AUDIOROOM_ERROR_ID_EXISTS;
					g_snprintf(error_cause, 512, "User ID %"SCNu64" already exists", user_id);
					goto error;
				}
			}
			if(user_id == 0) {
				/* Generate a random ID */
				while(user_id == 0) {
					user_id = g_random_int();
					if(g_hash_table_lookup(audioroom->participants, GUINT_TO_POINTER(user_id)) != NULL) {
						/* User ID already taken, try another one */
						user_id = 0;
					}
				}
			}
			JANUS_LOG(LOG_VERB, "  -- Participant ID in new room %s: %"SCNu64"\n", room_id, user_id);
			participant->prebuffering = TRUE;
			/* Is the sampling rate of the new room the same as the one in the old room, or should we update the decoder/encoder? */
			cm_audioroom_room *old_audioroom = participant->room;
			/* Leave the old room first... */
			janus_mutex_lock(&old_audioroom->mutex);
			g_hash_table_remove(old_audioroom->participants, GUINT_TO_POINTER(participant->user_id));
			janus_mutex_unlock(&old_audioroom->mutex);
			if(old_audioroom->sampling_rate != audioroom->sampling_rate) {
				/* Create a new one that takes into account the sampling rate we want now */
				int error = 0;
				OpusEncoder *new_encoder = opus_encoder_create(audioroom->sampling_rate, 1, OPUS_APPLICATION_VOIP, &error);
				if(error != OPUS_OK) {
					if(new_encoder)
						opus_encoder_destroy(new_encoder);
					new_encoder = NULL;
					JANUS_LOG(LOG_ERR, "Error creating Opus encoder\n");
					error_code = CM_AUDIOROOM_ERROR_LIBOPUS_ERROR;
					g_snprintf(error_cause, 512, "Error creating Opus decoder");
					/* Join the old room again... */
					janus_mutex_lock(&old_audioroom->mutex);
					g_hash_table_insert(audioroom->participants, GUINT_TO_POINTER(participant->user_id), participant);
					janus_mutex_unlock(&old_audioroom->mutex);
					goto error;
				}
				if(audioroom->sampling_rate == 8000) {
					opus_encoder_ctl(new_encoder, OPUS_SET_MAX_BANDWIDTH(OPUS_BANDWIDTH_NARROWBAND));
				} else if(audioroom->sampling_rate == 12000) {
					opus_encoder_ctl(new_encoder, OPUS_SET_MAX_BANDWIDTH(OPUS_BANDWIDTH_MEDIUMBAND));
				} else if(audioroom->sampling_rate == 16000) {
					opus_encoder_ctl(new_encoder, OPUS_SET_MAX_BANDWIDTH(OPUS_BANDWIDTH_WIDEBAND));
				} else if(audioroom->sampling_rate == 24000) {
					opus_encoder_ctl(new_encoder, OPUS_SET_MAX_BANDWIDTH(OPUS_BANDWIDTH_SUPERWIDEBAND));
				} else if(audioroom->sampling_rate == 48000) {
					opus_encoder_ctl(new_encoder, OPUS_SET_MAX_BANDWIDTH(OPUS_BANDWIDTH_FULLBAND));
				} else {
					JANUS_LOG(LOG_WARN, "Unsupported sampling rate %d, setting 16kHz\n", audioroom->sampling_rate);
					audioroom->sampling_rate = 16000;
					opus_encoder_ctl(new_encoder, OPUS_SET_MAX_BANDWIDTH(OPUS_BANDWIDTH_WIDEBAND));
				}
				/* FIXME This settings should be configurable */
				opus_encoder_ctl(new_encoder, OPUS_SET_INBAND_FEC(USE_FEC));
				opus_encoder_ctl(new_encoder, OPUS_SET_COMPLEXITY(participant->opus_complexity));
				/* Opus decoder */
				error = 0;
				OpusDecoder *new_decoder = opus_decoder_create(audioroom->sampling_rate, 1, &error);
				if(error != OPUS_OK) {
					if(new_encoder)
						opus_encoder_destroy(new_encoder);
					new_encoder = NULL;
					if(new_decoder)
						opus_decoder_destroy(new_decoder);
					new_decoder = NULL;
					JANUS_LOG(LOG_ERR, "Error creating Opus encoder\n");
					error_code = CM_AUDIOROOM_ERROR_LIBOPUS_ERROR;
					g_snprintf(error_cause, 512, "Error creating Opus decoder");
					/* Join the old room again... */
					janus_mutex_lock(&old_audioroom->mutex);
					g_hash_table_insert(audioroom->participants, GUINT_TO_POINTER(participant->user_id), participant);
					janus_mutex_unlock(&old_audioroom->mutex);
					goto error;
				}
				participant->reset = FALSE;
				/* Destroy the previous encoder/decoder and update the references */
				if(participant->encoder)
					opus_encoder_destroy(participant->encoder);
				participant->encoder = new_encoder;
				if(participant->decoder)
					opus_decoder_destroy(participant->decoder);
				participant->decoder = new_decoder;
			}
			/* Everything looks fine, start by telling the folks in the old room this participant is going away */
			janus_mutex_lock(&old_audioroom->mutex);
			event = json_object();
			json_object_set_new(event, "audioroom", json_string("event"));
			json_object_set_new(event, "id", json_string(old_audioroom->room_id));
			json_object_set_new(event, "leaving", json_integer(participant->user_id));
			char *leaving_text = json_dumps(event, JSON_INDENT(3) | JSON_PRESERVE_ORDER);
			GHashTableIter iter;
			gpointer value;
			g_hash_table_iter_init(&iter, old_audioroom->participants);
			while (g_hash_table_iter_next(&iter, NULL, &value)) {
				cm_audioroom_participant *p = value;
				if(p == participant) {
					continue;	/* Skip the new participant itself */
				}
				JANUS_LOG(LOG_VERB, "Notifying participant %"SCNu64" (%s)\n", p->user_id, p->display ? p->display : "??");
				int ret = gateway->push_event(p->session->handle, &cm_audioroom_plugin, NULL, leaving_text, NULL, NULL);
				JANUS_LOG(LOG_VERB, "  >> %d (%s)\n", ret, janus_get_api_error(ret));
			}
			g_free(leaving_text);
			janus_mutex_unlock(&old_audioroom->mutex);
			/* Done, join the new one */
			janus_mutex_lock(&audioroom->mutex);
			participant->user_id = user_id;
			if(display_text) {
				g_free(participant->display);
				participant->display = display_text ? g_strdup(display_text) : NULL;
			}
			participant->room = audioroom;
			participant->muted = muted ? json_is_true(muted) : FALSE;	/* When switching to a new room, you're unmuted by default */
			if(quality) {
				participant->opus_complexity = complexity;
				if(participant->encoder)
					opus_encoder_ctl(participant->encoder, OPUS_SET_COMPLEXITY(participant->opus_complexity));
			}
			g_hash_table_insert(audioroom->participants, GUINT_TO_POINTER(user_id), participant);
			/* Notify the other participants */
			json_t *newuser = json_object();
			json_object_set_new(newuser, "audioroom", json_string("joined"));
			json_object_set_new(newuser, "id", json_string(audioroom->room_id));
			json_t *newuserlist = json_array();
			json_t *pl = json_object();
			json_object_set_new(pl, "userid", json_integer(participant->user_id));
			if(participant->display)
				json_object_set_new(pl, "display", json_string(participant->display));
			json_object_set_new(pl, "muted", json_string(participant->muted ? "true" : "false"));
			json_array_append_new(newuserlist, pl);
			json_object_set_new(newuser, "participants", newuserlist);
			char *newuser_text = json_dumps(newuser, JSON_INDENT(3) | JSON_PRESERVE_ORDER);
			json_decref(newuser);
			g_hash_table_iter_init(&iter, audioroom->participants);
			while (g_hash_table_iter_next(&iter, NULL, &value)) {
				cm_audioroom_participant *p = value;
				if(p == participant) {
					continue;
				}
				JANUS_LOG(LOG_VERB, "Notifying participant %"SCNu64" (%s)\n", p->user_id, p->display ? p->display : "??");
				int ret = gateway->push_event(p->session->handle, &cm_audioroom_plugin, NULL, newuser_text, NULL, NULL);
				JANUS_LOG(LOG_VERB, "  >> %d (%s)\n", ret, janus_get_api_error(ret));
			}
			g_free(newuser_text);
			/* Return a list of all available participants for the new participant now */
			json_t *list = json_array();
			g_hash_table_iter_init(&iter, audioroom->participants);
			while (g_hash_table_iter_next(&iter, NULL, &value)) {
				cm_audioroom_participant *p = value;
				if(p == participant) {
					continue;
				}
				json_t *pl = json_object();
				json_object_set_new(pl, "userid", json_integer(p->user_id));
				if(p->display)
					json_object_set_new(pl, "display", json_string(p->display));
				json_object_set_new(pl, "muted", json_string(p->muted ? "true" : "false"));
				json_array_append_new(list, pl);
			}
			event = json_object();
			json_object_set_new(event, "audioroom", json_string("roomchanged"));
			json_object_set_new(event, "id", json_string(audioroom->room_id));
			json_object_set_new(event, "userid", json_integer(user_id));
			json_object_set_new(event, "participants", list);
			janus_mutex_unlock(&audioroom->mutex);
		} else if(!strcasecmp(request_text, "leave")) {
			/* This participant is leaving */
			cm_audioroom_participant *participant = (cm_audioroom_participant *)session->participant;
			if(participant == NULL || participant->room == NULL) {
				JANUS_LOG(LOG_ERR, "Can't leave (not in a room)\n");
				error_code = CM_AUDIOROOM_ERROR_NOT_JOINED;
				g_snprintf(error_cause, 512, "Can't leave (not in a room)");
				goto error;
			}
			/* Tell everybody */
			cm_audioroom_room *audioroom = participant->room;
			janus_mutex_lock(&audioroom->mutex);
			event = json_object();
			json_object_set_new(event, "audioroom", json_string("event"));
			json_object_set_new(event, "id", json_string(audioroom->room_id));
			json_object_set_new(event, "leaving", json_integer(participant->user_id));
			char *leaving_text = json_dumps(event, JSON_INDENT(3) | JSON_PRESERVE_ORDER);
			GHashTableIter iter;
			gpointer value;
			g_hash_table_iter_init(&iter, audioroom->participants);
			while (g_hash_table_iter_next(&iter, NULL, &value)) {
				cm_audioroom_participant *p = value;
				if(p == participant) {
					continue;	/* Skip the new participant itself */
				}
				JANUS_LOG(LOG_VERB, "Notifying participant %"SCNu64" (%s)\n", p->user_id, p->display ? p->display : "??");
				int ret = gateway->push_event(p->session->handle, &cm_audioroom_plugin, NULL, leaving_text, NULL, NULL);
				JANUS_LOG(LOG_VERB, "  >> %d (%s)\n", ret, janus_get_api_error(ret));
			}
			g_free(leaving_text);
			/* Actually leave the room... */
			g_hash_table_remove(audioroom->participants, GUINT_TO_POINTER(participant->user_id));
			participant->room = NULL;
			/* Get rid of queued packets */
			janus_mutex_lock(&participant->qmutex);
			participant->active = FALSE;
			participant->prebuffering = TRUE;
			while(participant->inbuf) {
				GList *first = g_list_first(participant->inbuf);
				cm_audioroom_rtp_relay_packet *pkt = (cm_audioroom_rtp_relay_packet *)first->data;
				participant->inbuf = g_list_remove_link(participant->inbuf, first);
				first = NULL;
				if(pkt == NULL)
					continue;
				if(pkt->data)
					g_free(pkt->data);
				pkt->data = NULL;
				g_free(pkt);
				pkt = NULL;
			}
			janus_mutex_unlock(&participant->qmutex);
			/* Done */
			janus_mutex_unlock(&audioroom->mutex);
		} else {
			JANUS_LOG(LOG_ERR, "Unknown request '%s'\n", request_text);
			error_code = CM_AUDIOROOM_ERROR_INVALID_REQUEST;
			g_snprintf(error_cause, 512, "Unknown request '%s'", request_text);
			goto error;
		}

		/* Prepare JSON event */
		JANUS_LOG(LOG_VERB, "Preparing JSON event as a reply\n");
		char *event_text = json_dumps(event, JSON_INDENT(3) | JSON_PRESERVE_ORDER);
		json_decref(event);
		/* Any SDP to handle? */
		if(!msg->sdp) {
			int ret = gateway->push_event(msg->handle, &cm_audioroom_plugin, msg->transaction, event_text, NULL, NULL);
			JANUS_LOG(LOG_VERB, "  >> %d (%s)\n", ret, janus_get_api_error(ret));
		} else {
			JANUS_LOG(LOG_VERB, "This is involving a negotiation (%s) as well:\n%s\n", msg->sdp_type, msg->sdp);
			const char *type = NULL;
			if(!strcasecmp(msg->sdp_type, "offer"))
				type = "answer";
			if(!strcasecmp(msg->sdp_type, "answer"))
				type = "offer";
			/* Fill the SDP template and use that as our answer */
			cm_audioroom_participant *participant = (cm_audioroom_participant *)session->participant;
			char sdp[1024];
			/* What is the Opus payload type? */
			participant->opus_pt = janus_get_opus_pt(msg->sdp);
			JANUS_LOG(LOG_VERB, "Opus payload type is %d\n", participant->opus_pt);
			g_snprintf(sdp, 1024, sdp_template,
				janus_get_real_time(),			/* We need current time here */
				janus_get_real_time(),			/* We need current time here */
				participant->room->room_name,	/* Audio bridge name */
				participant->opus_pt,			/* Opus payload type */
				participant->opus_pt,			/* Opus payload type */
				participant->opus_pt, 			/* Opus payload type and room sampling rate */
				participant->room->sampling_rate);
			/* Did the peer negotiate video? */
			if(strstr(msg->sdp, "m=video") != NULL) {
				/* If so, reject it */
				g_strlcat(sdp, "m=video 0 RTP/SAVPF 0\r\n", 1024);
			}
			/* How long will the gateway take to push the event? */
			gint64 start = janus_get_monotonic_time();
			int res = gateway->push_event(msg->handle, &cm_audioroom_plugin, msg->transaction, event_text, type, sdp);
			JANUS_LOG(LOG_VERB, "  >> Pushing event: %d (took %"SCNu64" us)\n", res, janus_get_monotonic_time()-start);
			if(res != JANUS_OK) {
				/* TODO Failed to negotiate? We should remove this participant */
			} else {
				/* Notify all other participants that there's a new boy in town */
				cm_audioroom_room *audioroom = participant->room;
				janus_mutex_lock(&audioroom->mutex);
				json_t *list = json_array();
				json_t *pl = json_object();
				json_object_set_new(pl, "userid", json_integer(participant->user_id));
				if(participant->display)
					json_object_set_new(pl, "display", json_string(participant->display));
				json_object_set_new(pl, "muted", json_string(participant->muted ? "true" : "false"));
				json_array_append_new(list, pl);
				json_t *pub = json_object();
				json_object_set_new(pub, "audioroom", json_string("event"));
				json_object_set_new(pub, "id", json_string(participant->room->room_id));
				json_object_set_new(pub, "participants", list);
				char *pub_text = json_dumps(pub, JSON_INDENT(3) | JSON_PRESERVE_ORDER);
				json_decref(pub);
				GHashTableIter iter;
				gpointer value;
				g_hash_table_iter_init(&iter, audioroom->participants);
				while (g_hash_table_iter_next(&iter, NULL, &value)) {
					cm_audioroom_participant *p = value;
					if(p == participant) {
						continue;	/* Skip the new participant itself */
					}
					JANUS_LOG(LOG_VERB, "Notifying participant %"SCNu64" (%s)\n", p->user_id, p->display ? p->display : "??");
					int ret = gateway->push_event(p->session->handle, &cm_audioroom_plugin, NULL, pub_text, NULL, NULL);
					JANUS_LOG(LOG_VERB, "  >> %d (%s)\n", ret, janus_get_api_error(ret));
				}
				g_free(pub_text);
				participant->active = TRUE;
				janus_mutex_unlock(&audioroom->mutex);
			}
		}
		if(event_text)
			g_free(event_text);
		event_text = NULL;
		if(msg)
			cm_audioroom_message_free(msg);
		msg = NULL;

		continue;

error:
		{
			/* Prepare JSON error event */
			json_t *event = json_object();
			json_object_set_new(event, "audioroom", json_string("event"));
			json_object_set_new(event, "error_code", json_integer(error_code));
			json_object_set_new(event, "error", json_string(error_cause));
			char *event_text = json_dumps(event, JSON_INDENT(3) | JSON_PRESERVE_ORDER);
			json_decref(event);
			JANUS_LOG(LOG_VERB, "Pushing event: %s\n", event_text);
			int ret = gateway->push_event(msg->handle, &cm_audioroom_plugin, msg->transaction, event_text, NULL, NULL);
			JANUS_LOG(LOG_VERB, "  >> %d (%s)\n", ret, janus_get_api_error(ret));
			g_free(event_text);
			cm_audioroom_message_free(msg);
		}
	}
	g_free(error_cause);
	JANUS_LOG(LOG_VERB, "Leaving AudioBridge handler thread\n");
	return NULL;
}

/* Thread to mix the contributions from all participants */
static void *cm_audioroom_mixer_thread(void *data) {
	JANUS_LOG(LOG_VERB, "Audio bridge thread starting...\n");
	cm_audioroom_room *audioroom = (cm_audioroom_room *)data;
	if(!audioroom) {
		JANUS_LOG(LOG_ERR, "Invalid room!\n");
		return NULL;
	}
	JANUS_LOG(LOG_VERB, "Thread is for mixing room %s (%s) at rate %"SCNu32"...\n", audioroom->room_id, audioroom->room_name, audioroom->sampling_rate);

	/* Do we need to record the mix? */
	if(audioroom->record) {
		char filename[255];
		if(audioroom->record_file)
			g_snprintf(filename, 255, "%s/%s", cm_audioroom_settings.archive_path, audioroom->record_file);
		else
			g_snprintf(filename, 255, "/tmp/janus-audioroom-%s.wav", audioroom->room_id);
		audioroom->recording = fopen(filename, "wb");
		if(audioroom->recording == NULL) {
			JANUS_LOG(LOG_WARN, "Recording requested, but could NOT open file %s for writing...\n", filename);
		} else {
			JANUS_LOG(LOG_VERB, "Recording requested, opened file %s for writing\n", filename);
			/* Write WAV header */
			wav_header header = {
				{'R', 'I', 'F', 'F'},
				0,
				{'W', 'A', 'V', 'E'},
				{'f', 'm', 't', ' '},
				16,
				1,
				1,
				audioroom->sampling_rate,
				audioroom->sampling_rate * 2,
				2,
				16,
				{'d', 'a', 't', 'a'},
				0
			};
			if(fwrite(&header, 1, sizeof(header), audioroom->recording) != sizeof(header)) {
				JANUS_LOG(LOG_ERR, "Error writing WAV header...\n");
			}
		}
	}

	/* Buffer (we allocate assuming 48kHz, although we'll likely use less than that) */
	int samples = audioroom->sampling_rate/50;
	opus_int32 buffer[960], sumBuffer[960];
	opus_int16 outBuffer[960], *curBuffer = NULL;
	memset(buffer, 0, 960*4);
	memset(sumBuffer, 0, 960*4);
	memset(outBuffer, 0, 960*2);

	/* Timer */
	struct timeval now, before;
	gettimeofday(&before, NULL);
	now.tv_sec = before.tv_sec;
	now.tv_usec = before.tv_usec;
	time_t passed, d_s, d_us;

	/* RTP */
	gint16 seq = 0;
	gint32 ts = 0;

	/* Loop */
	int i=0;
	int count = 0, prev_count = 0;
	while(!g_atomic_int_get(&stopping) && audioroom->destroyed == 0) {	/* FIXME We need a per-room watchdog as well */
		/* See if it's time to prepare a frame */
		gettimeofday(&now, NULL);
		d_s = now.tv_sec - before.tv_sec;
		d_us = now.tv_usec - before.tv_usec;
		if(d_us < 0) {
			d_us += 1000000;
			--d_s;
		}
		passed = d_s*1000000 + d_us;
		if(passed < 15000) {	/* Let's wait about 15ms at max */
			usleep(1000);
			continue;
		}
		/* Update the reference time */
		before.tv_usec += 20000;
		if(before.tv_usec > 1000000) {
			before.tv_sec++;
			before.tv_usec -= 1000000;
		}
		/* Do we need to mix at all? */
		janus_mutex_lock_nodebug(&audioroom->mutex);
		count = g_hash_table_size(audioroom->participants);
		janus_mutex_unlock_nodebug(&audioroom->mutex);
		if(count == 0) {
			/* No participant, do nothing */
			if(prev_count > 0) {
				JANUS_LOG(LOG_VERB, "Last user just left room %s, going idle...\n", audioroom->room_id);
				prev_count = 0;
			}
			continue;
		}
		if(prev_count == 0) {
			JANUS_LOG(LOG_VERB, "First user just joined room %s, waking it up...\n", audioroom->room_id);
		}
		prev_count = count;
		/* Update RTP header information */
		seq++;
		ts += 960;
		/* Mix all contributions */
		janus_mutex_lock_nodebug(&audioroom->mutex);
		GList *participants_list = g_hash_table_get_values(audioroom->participants);
		janus_mutex_unlock_nodebug(&audioroom->mutex);
		for(i=0; i<samples; i++)
			buffer[i] = 0;
		GList *ps = participants_list;
		while(ps) {
			cm_audioroom_participant *p = (cm_audioroom_participant *)ps->data;
			janus_mutex_lock(&p->qmutex);
			if(!p->active || p->muted || p->prebuffering || !p->inbuf) {
				janus_mutex_unlock(&p->qmutex);
				ps = ps->next;
				continue;
			}
			GList *peek = g_list_first(p->inbuf);
			cm_audioroom_rtp_relay_packet *pkt = (cm_audioroom_rtp_relay_packet *)(peek ? peek->data : NULL);
			if(pkt != NULL) {
				curBuffer = (opus_int16 *)pkt->data;
				for(i=0; i<samples; i++)
					buffer[i] += curBuffer[i];
			}
			janus_mutex_unlock(&p->qmutex);
			ps = ps->next;
		}
		/* Are we recording the mix? (only do it if there's someone in, though...) */
		if(audioroom->recording != NULL && g_list_length(participants_list) > 0) {
			for(i=0; i<samples; i++) {
				/* FIXME Smoothen/Normalize instead of truncating? */
				outBuffer[i] = buffer[i];
			}
			fwrite(outBuffer, sizeof(opus_int16), samples, audioroom->recording);
		}
		/* Send proper packet to each participant (remove own contribution) */
		ps = participants_list;
		while(ps) {
			cm_audioroom_participant *p = (cm_audioroom_participant *)ps->data;
			cm_audioroom_rtp_relay_packet *pkt = NULL;
			janus_mutex_lock(&p->qmutex);
			if(p->active && !p->muted && !p->prebuffering && p->inbuf) {
				GList *first = g_list_first(p->inbuf);
				pkt = (cm_audioroom_rtp_relay_packet *)(first ? first->data : NULL);
				p->inbuf = g_list_delete_link(p->inbuf, first);
			}
			janus_mutex_unlock(&p->qmutex);
			curBuffer = (opus_int16 *)(pkt ? pkt->data : NULL);
			for(i=0; i<samples; i++)
				sumBuffer[i] = buffer[i] - (curBuffer ? (curBuffer[i]) : 0);
			for(i=0; i<samples; i++)
				/* FIXME Smoothen/Normalize instead of truncating? */
				outBuffer[i] = sumBuffer[i];
			/* Enqueue this mixed frame for encoding in the participant thread */
			cm_audioroom_rtp_relay_packet *mixedpkt = g_malloc0(sizeof(cm_audioroom_rtp_relay_packet));
			if(mixedpkt != NULL) {
				mixedpkt->data = g_malloc0(samples*2);
				if(mixedpkt->data == NULL) {
					JANUS_LOG(LOG_FATAL, "Memory error!\n");
					g_free(mixedpkt);
				} else {
					memcpy(mixedpkt->data, outBuffer, samples*2);
					mixedpkt->length = samples;	/* We set the number of samples here, not the data length */
					mixedpkt->timestamp = ts;
					mixedpkt->seq_number = seq;
					mixedpkt->ssrc = g_str_hash(audioroom->room_id);
					g_async_queue_push(p->outbuf, mixedpkt);
				}
			}
			if(pkt) {
				if(pkt->data)
					g_free(pkt->data);
				pkt->data = NULL;
				g_free(pkt);
				pkt = NULL;
			}
			ps = ps->next;
		}
		g_list_free(participants_list);
	}
	if(audioroom->recording)
		fclose(audioroom->recording);
	JANUS_LOG(LOG_VERB, "Leaving mixer thread for room %s (%s)...\n", audioroom->room_id, audioroom->room_name);

	/* Free resources */
	g_free(audioroom->room_id);
	g_free(audioroom->room_name);
	g_free(audioroom->room_secret);
	g_free(audioroom->room_pin);
	g_free(audioroom->record_file);
	g_hash_table_destroy(audioroom->participants);
	g_free(audioroom);

	return NULL;
}

/* Thread to encode a mixed frame and send it to a specific participant */
static void *cm_audioroom_participant_thread(void *data) {
	JANUS_LOG(LOG_VERB, "AudioBridge Participant thread starting...\n");
	cm_audioroom_participant *participant = (cm_audioroom_participant *)data;
	if(!participant) {
		JANUS_LOG(LOG_ERR, "Invalid participant!\n");
		g_thread_unref(g_thread_self());
		return NULL;
	}
	JANUS_LOG(LOG_VERB, "Thread is for participant %"SCNu64" (%s)\n", participant->user_id, participant->display ? participant->display : "??");
	cm_audioroom_session *session = participant->session;

	/* Output buffer */
	cm_audioroom_rtp_relay_packet *outpkt = g_malloc0(sizeof(cm_audioroom_rtp_relay_packet));
	if(outpkt == NULL) {
		JANUS_LOG(LOG_FATAL, "Memory error!\n");
		g_thread_unref(g_thread_self());
		return NULL;
	}
	outpkt->data = (rtp_header *)g_malloc0(1500);
	if(outpkt->data == NULL) {
		JANUS_LOG(LOG_FATAL, "Memory error!\n");
		g_free(outpkt);
		g_thread_unref(g_thread_self());
		return NULL;
	}
	outpkt->ssrc = 0;
	outpkt->timestamp = 0;
	outpkt->seq_number = 0;
	unsigned char *payload = (unsigned char *)outpkt->data;
	memset(payload, 0, 1500);

	cm_audioroom_rtp_relay_packet *mixedpkt = NULL;

	/* Start working: check the outgoing queue for packets, then encode and send them */
	while(!g_atomic_int_get(&stopping) && session->destroyed == 0) {
		if(!participant->active || !participant->encoder) {
			/* Wait until the participant is in a room */
			g_usleep(10000);
			continue;
		}
		if(g_async_queue_length(participant->outbuf) == 0) {
			/* Nothing to do */
			g_usleep(5000);
			continue;
		}
		mixedpkt = g_async_queue_pop(participant->outbuf);
		if(mixedpkt != NULL && session->destroyed == 0) {
			/* Encode raw frame to Opus */
			if(participant->active && participant->encoder) {
				participant->working = TRUE;
				opus_int16 *outBuffer = (opus_int16 *)mixedpkt->data;
				outpkt->length = opus_encode(participant->encoder, outBuffer, mixedpkt->length, payload+12, BUFFER_SAMPLES-12);
				participant->working = FALSE;
				if(outpkt->length < 0) {
					JANUS_LOG(LOG_ERR, "[Opus] Ops! got an error encoding the Opus frame: %d (%s)\n", outpkt->length, opus_strerror(outpkt->length));
				} else {
					outpkt->length += 12;	/* Take the RTP header into consideration */
					/* Update RTP header */
					outpkt->data->version = 2;
					outpkt->data->markerbit = 0;	/* FIXME Should be 1 for the first packet */
					outpkt->data->seq_number = htons(mixedpkt->seq_number);
					outpkt->data->timestamp = htonl(mixedpkt->timestamp);
					outpkt->data->ssrc = htonl(mixedpkt->ssrc);	/* The gateway will fix this anyway */
					/* Backup the actual timestamp and sequence number set by the audioroom, in case a room is changed */
					outpkt->ssrc = mixedpkt->ssrc;
					outpkt->timestamp = mixedpkt->timestamp;
					outpkt->seq_number = mixedpkt->seq_number;
					cm_audioroom_relay_rtp_packet(participant->session, outpkt);
				}
			}
			if(mixedpkt) {
				if(mixedpkt->data)
					g_free(mixedpkt->data);
				mixedpkt->data = NULL;
				g_free(mixedpkt);
				mixedpkt = NULL;
			}
		}
	}
	/* We're done, get rid of the resources */
	if(outpkt != NULL) {
		if(outpkt->data != NULL) {
			g_free(outpkt->data);
			outpkt->data = NULL;
		}
		g_free(outpkt);
		outpkt = NULL;
	}
	/* Empty the outgoing queue if there was something still in */
	while(g_async_queue_length(participant->outbuf) > 0) {
		cm_audioroom_rtp_relay_packet *pkt = g_async_queue_pop(participant->outbuf);
		if(pkt == NULL)
			continue;
		if(pkt->data)
			g_free(pkt->data);
		pkt->data = NULL;
		g_free(pkt);
		pkt = NULL;
	}
	JANUS_LOG(LOG_VERB, "AudioBridge Participant thread leaving...\n");
	return NULL;
}

static void cm_audioroom_relay_rtp_packet(gpointer data, gpointer user_data) {
	cm_audioroom_rtp_relay_packet *packet = (cm_audioroom_rtp_relay_packet *)user_data;
	if(!packet || !packet->data || packet->length < 1) {
		JANUS_LOG(LOG_ERR, "Invalid packet...\n");
		return;
	}
	cm_audioroom_session *session = (cm_audioroom_session *)data;
	if(!session || !session->handle) {
		// JANUS_LOG(LOG_ERR, "Invalid session...\n");
		return;
	}
	if(!session->started) {
		// JANUS_LOG(LOG_ERR, "Streaming not started yet for this session...\n");
		return;
	}
	cm_audioroom_participant *participant = session->participant;
	/* Set the payload type */
	packet->data->type = participant->opus_pt;
	/* Fix sequence number and timestamp (room switching may be involved) */
	if(ntohl(packet->data->ssrc) != participant->context.a_last_ssrc) {
		participant->context.a_last_ssrc = ntohl(packet->data->ssrc);
		participant->context.a_base_ts_prev = participant->context.a_last_ts;
		participant->context.a_base_ts = packet->timestamp;
		participant->context.a_base_seq_prev = participant->context.a_last_seq;
		participant->context.a_base_seq = packet->seq_number;
	}
	/* Compute a coherent timestamp and sequence number */
	participant->context.a_last_ts = (packet->timestamp-participant->context.a_base_ts)
		+ participant->context.a_base_ts_prev+960;	/* FIXME When switching, we assume Opus and so a 960 ts step */
	participant->context.a_last_seq = (packet->seq_number-participant->context.a_base_seq)+participant->context.a_base_seq_prev+1;
	/* Update the timestamp and sequence number in the RTP packet, and send it */
	packet->data->timestamp = htonl(participant->context.a_last_ts);
	packet->data->seq_number = htons(participant->context.a_last_seq);
	if(gateway != NULL)
		gateway->relay_rtp(session->handle, 0, (char *)packet->data, packet->length);
	/* Restore the timestamp and sequence number to what the publisher set them to */
	packet->data->timestamp = htonl(packet->timestamp);
	packet->data->seq_number = htons(packet->seq_number);
}
